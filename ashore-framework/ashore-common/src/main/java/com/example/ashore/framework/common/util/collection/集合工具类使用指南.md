# collection 包工具类完整使用指南

## 目录
- [一、包概览](#一包概览)
- [二、函数式编程基础知识](#二函数式编程基础知识)
- [三、CollectionUtils - 集合工具类](#三collectionutils---集合工具类)
- [四、ArrayUtils - 数组工具类](#四arrayutils---数组工具类)
- [五、MapUtils - Map工具类](#五maputils---map工具类)
- [六、SetUtils - Set工具类](#六setutils---set工具类)
- [七、实战场景总结](#七实战场景总结)

---

## 一、包概览

`com.example.ashore.framework.common.util.collection` 包提供了一套完整的集合操作工具类，基于 Java 8+ 函数式编程和 Stream API 设计，大幅简化业务代码中的集合操作。

### 1.1 包含的工具类

| 工具类 | 作用 | 核心能力 |
|--------|------|---------|
| `CollectionUtils` | 集合操作工具类 | 转换、过滤、分组、去重、比较等 30+ 方法 |
| `ArrayUtils` | 数组操作工具类 | 数组转换、安全访问、合并等 |
| `MapUtils` | Map操作工具类 | 安全查找、批量转换、容量优化 |
| `SetUtils` | Set操作工具类 | 快速创建不可变集合 |

### 1.2 设计理念

- **二次封装**: 基于 Hutool、Guava、Spring、Java Stream API 进行二次封装
- **空值安全**: 所有方法都对 null 和空集合进行了安全处理
- **链式调用**: 支持函数式编程风格，代码更简洁
- **性能优化**: 减少中间集合创建，避免 N+1 查询问题

### 1.3 为什么要二次封装？

虽然 Java Stream API、Hutool、Guava 都提供了丰富的集合操作方法，但二次封装带来以下优势：

1. **统一的API风格**: 提供一致的方法命名和参数顺序
2. **空值安全**: 原生 Stream 对 null 处理不友好，容易 NPE
3. **业务场景优化**: 针对常见业务场景（如 List 转 Map、分组）提供快捷方法
4. **减少样板代码**: 将常用的多步操作封装为单个方法

**对比示例**：

```java
// 原生 Stream API - 需要多步操作，且需要处理 null
List<Long> ids = users == null ? Collections.emptyList() :
    users.stream()
         .map(User::getId)
         .filter(Objects::nonNull)
         .collect(Collectors.toList());

// CollectionUtils - 一行搞定，自动处理 null
List<Long> ids = CollectionUtils.convertList(users, User::getId);
```

---

## 二、函数式编程基础知识

> ��学习 `CollectionUtils` 之前，需要先理解 Java 函数式接口的概念。这些接口定义了不同的函数签名，用于在 Lambda 表达式中传递行为。

### 2.1 核心函数式接口速查表

| 接口 | 参数 | 返回值 | 用途 | Lambda 示例 |
|------|------|--------|------|------------|
| `Predicate<T>` | T | boolean | 判断/过滤 | `user -> user.getAge() >= 18` |
| `Function<T, R>` | T | R | 转换/映射 | `User::getName` 或 `user -> user.getName()` |
| `BiFunction<T, U, R>` | T, U | R | 双参数转换 | `(u1, u2) -> u1.getId().equals(u2.getId())` |
| `BinaryOperator<T>` | T, T | T | 二元操作/合并 | `BigDecimal::add` 或 `(a, b) -> a + b` |
| `Supplier<T>` | 无 | T | 提供对象 | `ArrayList::new` |
| `Consumer<T>` | T | void | 消费/执行 | `user -> System.out.println(user)` |

### 2.2 详细说明

#### Predicate<T> - 断言/过滤器
- **作用**: 接收一个参数，返回布尔值，用于判断是否满足条件
- **典型场景**: 过滤集合中的元素

```java
// 示例1：判断是否成年
Predicate<User> isAdult = user -> user.getAge() >= 18;
boolean result = isAdult.test(user); // 返回 true/false

// 示例2：在过滤方法中使用
List<User> adults = CollectionUtils.filterList(users, user -> user.getAge() >= 18);
```

#### Function<T, R> - 转换函数
- **作用**: 接收类型 T，返回类型 R，用于类型转换或提取字段
- **典型场景**: 提取对象的某个属性

```java
// 示例1：提取用户名（方法引用）
Function<User, String> getName = User::getName;
String name = getName.apply(user);

// 示例2：提取用户名（Lambda表达式）
Function<User, String> getName2 = user -> user.getName();

// 示例3：在转换方法中使用
List<String> names = CollectionUtils.convertList(users, User::getName);
```

#### BiFunction<T, U, R> - 双参数函数
- **作用**: 接收两个参数（类型 T 和 U），返回类型 R
- **典型场景**: 比较两个对象是否相同

```java
// 示例：判断两个用户是否相同（通过ID）
BiFunction<User, User, Boolean> isSame = (u1, u2) -> u1.getId().equals(u2.getId());
boolean same = isSame.apply(user1, user2);

// 在 diffList 中使用
List<List<User>> diff = CollectionUtils.diffList(oldUsers, newUsers,
    (old, newUser) -> old.getId().equals(newUser.getId())
);
```

#### BinaryOperator<T> - 二元操作符
- **作用**: 接收两个相同类型的参数，返回同类型结果，常用于合并或累加
- **典型场景**: 求和、合并对象

```java
// 示例1：求和
BinaryOperator<Integer> sum = (a, b) -> a + b;
// 或使用方法引用
BinaryOperator<Integer> sum2 = Integer::sum;

// 示例2：BigDecimal 求和
BinaryOperator<BigDecimal> bigDecimalSum = BigDecimal::add;

// 在 getSumValue 中使用
BigDecimal total = CollectionUtils.getSumValue(products,
    Product::getPrice,
    BigDecimal::add
);
```

#### Supplier<T> - 供应商/提供者
- **作用**: 不接收参数，返回一个对象，用于延迟创建对象
- **典型场景**: 提供默认对象、工厂方法

```java
// 示例1：提供空列表
Supplier<List<String>> listSupplier = ArrayList::new;
List<String> list = listSupplier.get();

// 示例2：在 convertMap 中指定返回的 Map 类型
Map<Long, User> userMap = CollectionUtils.convertMap(users,
    User::getId,
    LinkedHashMap::new  // 使用 LinkedHashMap 保持插入顺序
);
```

#### Consumer<T> - 消费者
- **作用**: 接收一个参数，不返回结果，用于执行操作（如打印、修改）
- **典型场景**: 遍历集合、执行副作用操作

```java
// 示例1：打印用户名
Consumer<User> printName = user -> System.out.println(user.getName());
printName.accept(user);

// 示例2：批量修改
users.forEach(user -> user.setStatus(1)); // forEach 接收 Consumer
```

### 2.3 方法引用 vs Lambda 表达式

```java
// 方法引用（推荐，更简洁）
Function<User, String> getName1 = User::getName;
List<String> names1 = CollectionUtils.convertList(users, User::getName);

// Lambda 表达式（更灵活）
Function<User, String> getName2 = user -> user.getName();
List<String> names2 = CollectionUtils.convertList(users, user -> user.getName());

// 复杂逻辑必须用 Lambda
List<UserVO> vos = CollectionUtils.convertList(users, user -> {
    UserVO vo = new UserVO();
    vo.setId(user.getId());
    vo.setName(user.getName());
    vo.setAge(user.getAge());
    return vo;
});
```

---

## 三、CollectionUtils - 集合工具类

### 3.1 类的整体介绍

`CollectionUtils` 是项目中最强大的集合工具类，提供 30+ 个静态方法，涵盖集合转换、过滤、分组、去重、查找等常见操作。

**核心特点**:
- 所有方法都是静态的，通过 `CollectionUtils.方法名()` 调用
- 自动过滤 null 元素，避免 NPE
- 空集合安全，传入 null 或空集合会返回空集合，不会抛异常
- 基于 Stream API 实现，性能优秀

**依赖库**:
- Hutool (`cn.hutool.core.collection`)
- Guava (`com.google.common.collect`)
- Spring (`org.springframework.util.CollectionUtils`)
- Java Stream API

---

### 3.2 集合判断方法

#### 3.2.1 containsAny - 元素是否在数组中

**方法签名**:
```java
public static boolean containsAny(Object source, Object... targets)
```

**作用**: 判断 `source` 是否在 `targets` 数组中

**为什么封装**: 原生 Java 需要先创建数组再判断，代码冗长

**使用示例**:
```java
// 示例1：检查用户状态是否为待审核或已驳回
String status = "PENDING";
boolean needReview = CollectionUtils.containsAny(status, "PENDING", "REJECTED");
// 结果：true

// 示例2：判断订单状态是否可取消
Integer orderStatus = 1;
boolean canCancel = CollectionUtils.containsAny(orderStatus, 1, 2, 3);
```

**对比原生写法**:
```java
// 原生 Java
boolean needReview = Arrays.asList("PENDING", "REJECTED").contains(status);

// CollectionUtils（更简洁）
boolean needReview = CollectionUtils.containsAny(status, "PENDING", "REJECTED");
```

**项目实际使用**:
```java
// ashore-module-mp/MpMessageServiceImpl.java:95
if (!CollectionUtils.containsAny(message.getType(),
    MpMessageDO.REQUEST_MESSAGE_TYPE)) {
    throw exception(MESSAGE_TYPE_NOT_SUPPORT);
}
```

---

#### 3.2.2 isAnyEmpty - 是否有任一集合为空

**方法签名**:
```java
public static boolean isAnyEmpty(Collection<?>... collections)
```

**作用**: 判断多个集合中是否有任何一个为空

**使用示例**:
```java
// 示例：检查多个列表是否都有数据
List<User> users = getUserList();
List<Order> orders = getOrderList();
List<Product> products = getProductList();

if (CollectionUtils.isAnyEmpty(users, orders, products)) {
    throw new BusinessException("数据不完整，请检查");
}
```

**对比原生写法**:
```java
// 原生 Java（冗长）
if (CollectionUtil.isEmpty(users) ||
    CollectionUtil.isEmpty(orders) ||
    CollectionUtil.isEmpty(products)) {
    throw new BusinessException("数据不完整");
}

// CollectionUtils（简洁）
if (CollectionUtils.isAnyEmpty(users, orders, products)) {
    throw new BusinessException("数据不完整");
}
```

---

#### 3.2.3 anyMatch - 是否有任一元素满足条件

**方法签名**:
```java
public static <T> boolean anyMatch(Collection<T> from, Predicate<T> predicate)
```

**作用**: 判断集合中是否有任何元素满足条件

**为什么封装**: 提供更友好的 API，避免直接使用 Stream

**使用示例**:
```java
// 示例1：检查是否有成年用户
List<User> users = getUserList();
boolean hasAdult = CollectionUtils.anyMatch(users, user -> user.getAge() >= 18);

// 示例2：检查订单中是否有未支付的
List<Order> orders = getOrders();
boolean hasUnpaid = CollectionUtils.anyMatch(orders, order -> order.getStatus() == 0);
```

**项目实际使用**:
```java
// ashore-module-mall/TradeDeliveryPriceCalculator.java:60
// 校验是否存在商品不支持选定的配送方式
if (CollectionUtils.anyMatch(result.getItems(),
        item -> !item.getDeliveryTypes().contains(param.getDeliveryType()))) {
    throw exception(PRICE_CALCULATE_DELIVERY_PRICE_TYPE_ILLEGAL);
}
```

---

### 3.3 集合过滤方法

#### 3.3.1 filterList - 条件过滤

**方法签名**:
```java
public static <T> List<T> filterList(Collection<T> from, Predicate<T> predicate)
```

**作用**: 过滤集合，返回满足条件的元素列表

**为什么封装**:
- 自动处理空集合，避免 NPE
- 返回新的 ArrayList，不影响原集合
- 简化 Stream 操作

**使用示例**:
```java
// 示例1：筛选出所有已激活的用户
List<User> allUsers = getAllUsers();
List<User> activeUsers = CollectionUtils.filterList(allUsers, user -> user.isActive());

// 示例2：筛选出价格大于100的商品
List<Product> products = getProducts();
List<Product> expensiveProducts = CollectionUtils.filterList(products,
    product -> product.getPrice().compareTo(new BigDecimal("100")) > 0
);

// 示例3：筛选出本月的订单
List<Order> orders = getOrders();
List<Order> thisMonthOrders = CollectionUtils.filterList(orders, order -> {
    LocalDate orderDate = order.getCreateTime().toLocalDate();
    LocalDate now = LocalDate.now();
    return orderDate.getYear() == now.getYear() &&
           orderDate.getMonth() == now.getMonth();
});
```

**项目实际使用场景1**:
```java
// ashore-module-crm/CrmCustomerController.java:201
// 过滤出符合公海池规则的客户
list = CollectionUtils.filterList(list, customer -> {
    // 特殊：如果没负责人，则说明已经在公海,不用计算
    if (customer.getOwnerUserId() == null) {
        return false;
    }
    // 已成交 or 已锁定,不进入公海
    return !customer.getDealStatus() && !customer.getLockStatus();
});
```

**项目实际使用场景2**:
```java
// ashore-module-mall/TradeOrderHandler.java:95
// 过滤出没有售后的订单项
default List<TradeOrderItemDO> filterOrderItemListByNoneAfterSale(
        List<TradeOrderItemDO> orderItems) {
    return CollectionUtils.filterList(orderItems,
            item -> TradeOrderItemAfterSaleStatusEnum.isNone(item.getAfterSaleStatus()));
}
```

---

#### 3.3.2 distinct - 去重

**方法签名1** (保留第一个):
```java
public static <T, R> List<T> distinct(Collection<T> from, Function<T, R> keyMapper)
```

**方法签名2** (自定义保留策略):
```java
public static <T, R> List<T> distinct(Collection<T> from,
                                      Function<T, R> keyMapper,
                                      BinaryOperator<T> cover)
```

**作用**: 根据指定的键去重

**为什么封装**: Stream 的 `distinct()` 只能根据对象的 `equals()` 去重，无法按指定字段去重

**使用示例**:
```java
// 示例1：按用户ID去重（保留第一个）
List<User> users = getUserList();
List<User> uniqueUsers = CollectionUtils.distinct(users, User::getId);

// 示例2：按邮箱去重
List<User> uniqueByEmail = CollectionUtils.distinct(users, User::getEmail);

// 示例3：按ID去重，保留更新时间最新的
List<User> users = getUserList();
List<User> latestUsers = CollectionUtils.distinct(
    users,
    User::getId,
    (u1, u2) -> u1.getUpdateTime().after(u2.getUpdateTime()) ? u1 : u2
);

// 示例4：按部门ID去重，保留年龄最大的员工
List<Employee> employees = getEmployees();
List<Employee> oldestByDept = CollectionUtils.distinct(
    employees,
    Employee::getDeptId,
    (e1, e2) -> e1.getAge() > e2.getAge() ? e1 : e2
);
```

**对比原生写法**:
```java
// 原生 Stream API（复杂）
List<User> uniqueUsers = new ArrayList<>(users.stream()
    .collect(Collectors.toMap(User::getId, Function.identity(), (v1, v2) -> v1))
    .values());

// CollectionUtils（简洁）
List<User> uniqueUsers = CollectionUtils.distinct(users, User::getId);
```

---

### 3.4 集合转换方法（最常用）

#### 3.4.1 convertList - 集合元素类型转换

**方法签名1** (基础转换):
```java
public static <T, U> List<U> convertList(Collection<T> from, Function<T, U> func)
```

**方法签名2** (先过滤再转换):
```java
public static <T, U> List<U> convertList(Collection<T> from,
                                         Function<T, U> func,
                                         Predicate<T> filter)
```

**作用**: 将集合中的每个元素转换为另一种类型

**为什么封装**:
- 自动过滤 null 元素（转换前和转换后）
- 空集合安全处理
- 代码更简洁直观

**加强了什么功能**:
- 原生 Stream 的 `map()` 不会过滤 null 结果，容易导致 NPE
- 封装后自动执行 `filter(Objects::nonNull)`

**使用示例**:
```java
// 示例1：提取用户名列表
List<User> users = getUserList();
List<String> names = CollectionUtils.convertList(users, User::getName);
// 结果：["张三", "李四", "王五"]

// 示例2：提取用户ID列表
List<Long> userIds = CollectionUtils.convertList(users, User::getId);
// 结果：[1L, 2L, 3L]

// 示例3：将DO转换为VO
List<UserDO> userDOs = userMapper.selectList();
List<UserVO> userVOs = CollectionUtils.convertList(userDOs, user -> {
    UserVO vo = new UserVO();
    vo.setId(user.getId());
    vo.setName(user.getName());
    vo.setAge(user.getAge());
    return vo;
});

// 示例4：先过滤再转换 - 获取所有成年用户的姓名
List<String> adultNames = CollectionUtils.convertList(
    users,
    User::getName,
    user -> user.getAge() >= 18
);
```

**项目实际使用场景1**:
```java
// ashore-module-crm/CrmPermissionServiceImpl.java:184
// 将ID列表转换为待更新的权限对象列表
List<CrmPermissionDO> updateList = CollectionUtils.convertList(updateReqVO.getIds(),
        id -> new CrmPermissionDO().setId(id).setLevel(updateReqVO.getLevel()));
permissionMapper.updateBatch(updateList);
```

**项目实际使用场景2**:
```java
// ashore-module-mp/MpUserServiceImpl.java:142
// 从微信用户对象列表中提取OpenID列表
List<MpUserDO> dbUsers = mpUserMapper.selectListByAppIdAndOpenid(
    account.getAppId(),
    CollectionUtils.convertList(wxUsers, WxMpUser::getOpenId)
);
```

---

#### 3.4.2 convertSet - 集合转Set（自动去重）

**方法签名1** (保持元素不变):
```java
public static <T> Set<T> convertSet(Collection<T> from)
```

**方法签名2** (转换元素类型):
```java
public static <T, U> Set<U> convertSet(Collection<T> from, Function<T, U> func)
```

**方法签名3** (先过滤再转换):
```java
public static <T, U> Set<U> convertSet(Collection<T> from,
                                       Function<T, U> func,
                                       Predicate<T> filter)
```

**作用**: 转换为 Set 集合（自动去重）

**使用示例**:
```java
// 示例1：提取所有商品的分类（去重）
List<Product> products = getProducts();
Set<String> categories = CollectionUtils.convertSet(products, Product::getCategory);
// 结果：["电子", "服装", "食品"] （自动去重）

// 示例2：获取所有用户ID（去重）
List<Order> orders = getOrders();
Set<Long> userIds = CollectionUtils.convertSet(orders, Order::getUserId);

// 示例3：获取所有已激活用户的部门ID
Set<Long> deptIds = CollectionUtils.convertSet(users,
    User::getDeptId,
    User::isActive
);
```

**项目实际使用**:
```java
// ashore-module-system/TenantServiceImpl.java:304
// 从菜单列表中提取所有菜单ID，自动去重
Set<Long> menuIds;
if (isSystemTenant(tenant)) { // 系统租户，菜单是全量的
    menuIds = CollectionUtils.convertSet(menuService.getMenuList(), MenuDO::getId);
} else {
    menuIds = tenantPackageService.getTenantPackage(tenant.getPackageId()).getMenuIds();
}
```

---

#### 3.4.3 convertMap - 列表转Map

**方法签名1** (值为元素本身):
```java
public static <T, K> Map<K, T> convertMap(Collection<T> from, Function<T, K> keyFunc)
```

**方法签名2** (自定义键和值):
```java
public static <T, K, V> Map<K, V> convertMap(Collection<T> from,
                                             Function<T, K> keyFunc,
                                             Function<T, V> valueFunc)
```

**方法签名3** (处理键冲突):
```java
public static <T, K, V> Map<K, V> convertMap(Collection<T> from,
                                             Function<T, K> keyFunc,
                                             Function<T, V> valueFunc,
                                             BinaryOperator<V> mergeFunction)
```

**作用**: 将列表转换为 Map

**为什么封装**:
- 简化 `Collectors.toMap()` 的使用
- 提供默认的键冲突处理策略（保留第一个）
- 空集合安全

**使用示例**:
```java
// 示例1：构建用户ID到用户对象的映射
List<User> users = getUserList();
Map<Long, User> userMap = CollectionUtils.convertMap(users, User::getId);
// 结果：{1L: User(id=1, name="张三"), 2L: User(id=2, name="李四"), ...}

// 示例2：构建用户ID到用户名的映射
Map<Long, String> idToNameMap = CollectionUtils.convertMap(
    users,
    User::getId,
    User::getName
);
// 结果：{1L: "张三", 2L: "李四", 3L: "王五"}

// 示例3：处理键冲突 - 保留年龄较大的用户
Map<String, User> deptUserMap = CollectionUtils.convertMap(
    users,
    User::getDeptName,  // 部门名称作为key（可能重复）
    Function.identity(), // 用户对象作为value
    (u1, u2) -> u1.getAge() > u2.getAge() ? u1 : u2  // 保留年龄大的
);
```

**典型应用场景 - 批量查询后快速查找**:
```java
// 场景：订单列表需要填充用户信息
List<Order> orders = orderMapper.selectList();

// 1. 提取所有用户ID
Set<Long> userIds = CollectionUtils.convertSet(orders, Order::getUserId);

// 2. 批量查询用户（避免 N+1 问题）
List<User> users = userMapper.selectByIds(userIds);

// 3. 构建 ID -> User 的映射
Map<Long, User> userMap = CollectionUtils.convertMap(users, User::getId);

// 4. 填充订单的用户信息（O(1) 查找）
orders.forEach(order -> {
    User user = userMap.get(order.getUserId());
    if (user != null) {
        order.setUserName(user.getName());
        order.setUserMobile(user.getMobile());
    }
});
```

**项目实际使用**:
```java
// ashore-module-mp/MpUserServiceImpl.java:143
// 将数据库用户列表转换为以OpenID为key的Map，方便快速查找
Map<String, MpUserDO> openId2Users = CollectionUtils.convertMap(dbUsers,
    MpUserDO::getOpenid);

// 后续使用
wxUsers.forEach(user -> {
    MpUserDO dbUser = openId2Users.get(user.getOpenid());
    if (dbUser == null) { // 新增
        newUsers.add(user);
    } else { // 更新
        user.setId(dbUser.getId());
        mpUserMapper.updateById(user);
    }
});
```

---

### 3.5 集合分组方法（一对多）

#### 3.5.1 convertMultiMap - 按键分组（值为对象列表）

**方法签名1** (值为元素本身):
```java
public static <T, K> Map<K, List<T>> convertMultiMap(Collection<T> from,
                                                      Function<T, K> keyFunc)
```

**方法签名2** (值为转换后的结果):
```java
public static <T, K, V> Map<K, List<V>> convertMultiMap(Collection<T> from,
                                                         Function<T, K> keyFunc,
                                                         Function<T, V> valueFunc)
```

**作用**: 按 key 分组，返回 `Map<K, List<V>>`（一对多关系）

**为什么封装**:
- 简化 `Collectors.groupingBy()` 的使用
- 自动处理空集合
- 更直观的 API

**使用示例**:
```java
// 示例1：按部门分组用户
List<User> users = getUserList();
Map<Long, List<User>> deptUserMap = CollectionUtils.convertMultiMap(users,
    User::getDeptId);
// 结果：{
//   1L: [User(deptId=1, name="张三"), User(deptId=1, name="李四")],
//   2L: [User(deptId=2, name="王五")]
// }

// 使用示例
Long deptId = 1L;
List<User> deptUsers = deptUserMap.get(deptId);  // 获取部门1的所有用户
int userCount = deptUsers.size();  // 统计部门人数

// 示例2：按部门分组，只保留用户名
Map<Long, List<String>> deptNameMap = CollectionUtils.convertMultiMap(
    users,
    User::getDeptId,
    User::getName
);
// 结果：{1L: ["张三", "李四"], 2L: ["王五"]}

// 示例3：按分类分组商品
List<Product> products = getProducts();
Map<String, List<Product>> categoryProductMap =
    CollectionUtils.convertMultiMap(products, Product::getCategory);
```

**典型应用场景 - 主从表数据组装**:
```java
// 场景：查询订单及其订单项
// 1. 查询订单列表
List<Order> orders = orderMapper.selectList();
List<Long> orderIds = CollectionUtils.convertList(orders, Order::getId);

// 2. 查询所有订单项
List<OrderItem> items = orderItemMapper.selectByOrderIds(orderIds);

// 3. 按订单ID分组订单项
Map<Long, List<OrderItem>> orderItemMap =
    CollectionUtils.convertMultiMap(items, OrderItem::getOrderId);

// 4. 填充订单的订单项
orders.forEach(order -> {
    List<OrderItem> orderItems = orderItemMap.get(order.getId());
    order.setItems(orderItems != null ? orderItems : Collections.emptyList());
});
```

**项目实际使用场景1**:
```java
// ashore-module-bpm/BpmTaskService.java:74
// 将任务列表转换为以流程实例ID为key的Map，value是任务列表
default Map<String, List<Task>> getTaskMapByProcessInstanceIds(
        List<String> processInstanceIds) {
    return CollectionUtils.convertMultiMap(getTasksByProcessInstanceIds(processInstanceIds),
            Task::getProcessInstanceId);
}
```

**项目实际使用场景2**:
```java
// ashore-module-erp/ErpStockOutController.java:42
// 将出库单明细按出库单ID分组
Map<Long, List<ErpStockOutItemDO>> itemMap =
    convertMultiMap(items, ErpStockOutItemDO::getOutId);
```

---

#### 3.5.2 convertMultiMap2 - 按键分组（值为Set）

**方法签名**:
```java
public static <T, K, V> Map<K, Set<V>> convertMultiMap2(Collection<T> from,
                                                        Function<T, K> keyFunc,
                                                        Function<T, V> valueFunc)
```

**作用**: 按 key 分组，value 是 Set（自动去重）

**使用示例**:
```java
// 示例：统计每个部门的角色（去重）
List<User> users = getUserList();
Map<Long, Set<String>> deptRoleMap = CollectionUtils.convertMultiMap2(
    users,
    User::getDeptId,
    User::getRole
);
// 结果：{1L: ["管理员", "开发"], 2L: ["测试", "运维"]}
```

**项目实际使用**:
```java
// ashore-module-pay/PayAppConvert.java:44
// 将支付渠道列表转换为Map<应用ID, Set<渠道代码>>
Map<Long, Set<String>> appIdChannelMap = CollectionUtils.convertMultiMap2(
    channels,
    PayChannelDO::getAppId,
    PayChannelDO::getCode
);
voPageResult.getList().forEach(app ->
    app.setChannelCodes(appIdChannelMap.get(app.getId()))
);
```

---

### 3.6 集合扁平化方法（处理嵌套集合）

#### 3.6.1 convertListByFlatMap - 嵌套集合拍平

**方法签名1** (一级展开):
```java
public static <T, U> List<U> convertListByFlatMap(Collection<T> from,
                                                   Function<T, Stream<U>> func)
```

**方法签名2** (两级展开):
```java
public static <T, U, R> List<R> convertListByFlatMap(Collection<T> from,
                                                      Function<T, U> mapper,
                                                      Function<U, Stream<R>> func)
```

**作用**: 将嵌套集合"拍平"成一维集合

**为什么封装**:
- 简化 `flatMap` 操作
- 自动过滤 null

**使用示例**:
```java
// 示例1：获取所有用户的所有角色（用户有多个角色）
List<User> users = getUserList();  // 每个用户有 roles 字段 (List<Role>)
List<Role> allRoles = CollectionUtils.convertListByFlatMap(
    users,
    user -> user.getRoles().stream()
);
// 结果：所有用户的角色合并到一个列表中

// 示例2：订单 -> 订单项
List<Order> orders = getOrders();  // 每个订单有多个订单项
List<OrderItem> allItems = CollectionUtils.convertListByFlatMap(
    orders,
    order -> order.getItems().stream()
);

// 示例3：部门 -> 员工 -> 技能
List<Dept> depts = getDepts();  // 部门 -> 员工 -> 技能
List<String> allSkills = CollectionUtils.convertListByFlatMap(
    depts,
    Dept::getEmployees,  // 部门 -> 员工
    employees -> employees.stream().flatMap(e -> e.getSkills().stream())
);
```

**典型应用场景 - 统计树形结构中的所有叶子节点**:
```java
// 场景：获取部门树中所有用户
List<Dept> deptTree = getDeptTree();  // 树形结构，每个部门有子部门和用户
List<User> allUsers = CollectionUtils.convertListByFlatMap(
    deptTree,
    dept -> dept.getUsers().stream()
);
```

---

#### 3.6.2 convertSetByFlatMap - 嵌套集合拍平为Set

**方法签名1**:
```java
public static <T, U> Set<U> convertSetByFlatMap(Collection<T> from,
                                                Function<T, Stream<U>> func)
```

**方法签名2**:
```java
public static <T, U, R> Set<R> convertSetByFlatMap(Collection<T> from,
                                                   Function<T, U> mapper,
                                                   Function<U, Stream<R>> func)
```

**作用**: 将嵌套集合拍平为 Set（自动去重）

**使用示例**:
```java
// 示例：获取所有用户的所有角色代码（去重）
List<User> users = getUserList();
Set<String> roleCodes = CollectionUtils.convertSetByFlatMap(
    users,
    user -> user.getRoles().stream().map(Role::getCode)
);
```

---

### 3.7 集合查找方法

#### 3.7.1 findFirst - 查找第一个满足条件的元素

**方法签名1** (返回元素本身):
```java
public static <T> T findFirst(Collection<T> from, Predicate<T> predicate)
```

**方法签名2** (转换后返回):
```java
public static <T, U> U findFirst(Collection<T> from,
                                Predicate<T> predicate,
                                Function<T, U> func)
```

**作用**: 查找第一个满足条件的元素

**为什么封装**:
- 简化 Stream 的 `filter().findFirst().orElse(null)` 操作
- 自动处理空集合

**使用示例**:
```java
// 示例1：查找第一个管理员用户
List<User> users = getUserList();
User admin = CollectionUtils.findFirst(users,
    user -> "ADMIN".equals(user.getRole()));
// 如果找不到，返回 null

// 示例2：查找第一个成年用户的姓名
String adultName = CollectionUtils.findFirst(
    users,
    user -> user.getAge() >= 18,
    User::getName
);
// 结果：返回第一个成年用户的姓名，找不到返回 null
```

**项目实际使用场景1**:
```java
// ashore-module-infra/CodegenEngine.java:424
// 从字段列表中查找主键字段
bindingMap.put("primaryColumn",
    CollectionUtils.findFirst(columns, CodegenColumnDO::getPrimaryKey));
```

**项目实际使用场景2**:
```java
// ashore-module-mall/CombinationActivityConvert.java:199
// 从所有拼团记录中查找当前用户的记录
CombinationRecordDO userRecord = CollectionUtils.findFirst(memberRecords,
    r -> ObjectUtil.equal(r.getUserId(), userId));
```

---

#### 3.7.2 getFirst - 获取列表第一个元素

**方法签名**:
```java
public static <T> T getFirst(List<T> from)
```

**作用**: 获取列表的第一个元素（安全方法，不会抛异常）

**为什么封装**:
- 避免 `list.get(0)` 的 `IndexOutOfBoundsException`
- 自动处理 null 和空列表

**使用示例**:
```java
// 示例：获取第一个用户
List<User> users = getUserList();
User firstUser = CollectionUtils.getFirst(users);
// 如果列表为空，返回 null（不会抛 IndexOutOfBoundsException）

// 对比原生写法
User firstUser = users != null && !users.isEmpty() ? users.get(0) : null;
```

**项目实际使用**:
```java
// ashore-module-mall/TradeConfigServiceImpl.java:41
// 获取交易配置（单例配置）
return CollectionUtils.getFirst(list);
```

---

#### 3.7.3 getMaxValue - 获取最大值

**方法签名**:
```java
public static <T, V extends Comparable<? super V>> V getMaxValue(Collection<T> from,
                                                                 Function<T, V> valueFunc)
```

**作用**: 获取集合中某个字段的最大值

**使用示例**:
```java
// 示例1：获取最高价格
List<Product> products = getProducts();
BigDecimal maxPrice = CollectionUtils.getMaxValue(products, Product::getPrice);

// 示例2：获取最晚的更新时间
List<User> users = getUsers();
Date latestUpdate = CollectionUtils.getMaxValue(users, User::getUpdateTime);

// 示例3：获取年龄最大的员工年龄
Integer maxAge = CollectionUtils.getMaxValue(employees, Employee::getAge);
```

---

#### 3.7.4 getMinValue - 获取最小值

**方法签名**:
```java
public static <T, V extends Comparable<? super V>> V getMinValue(List<T> from,
                                                                 Function<T, V> valueFunc)
```

**作用**: 获取集合中某个字段的最小值

**使用示例**:
```java
// 示例1：获取最低价格
List<Product> products = getProducts();
BigDecimal minPrice = CollectionUtils.getMinValue(products, Product::getPrice);

// 示例2：获取最早的创建时间
Date earliestCreate = CollectionUtils.getMinValue(orders, Order::getCreateTime);
```

---

#### 3.7.5 getMinObject - 获取最小值对应的对象

**方法签名**:
```java
public static <T, V extends Comparable<? super V>> T getMinObject(List<T> from,
                                                                  Function<T, V> valueFunc)
```

**作用**: 返回字段值最小的那个对象（而不是字段值本身）

**使用示例**:
```java
// 示例：获取价格最低的商品
List<Product> products = getProducts();
Product cheapestProduct = CollectionUtils.getMinObject(products, Product::getPrice);
// 返回商品对象，而不是价格本身
```

---

### 3.8 集合聚合方法

#### 3.8.1 getSumValue - 求和

**方法签名1**:
```java
public static <T, V extends Comparable<? super V>> V getSumValue(Collection<T> from,
                                                                 Function<T, V> valueFunc,
                                                                 BinaryOperator<V> accumulator)
```

**方法签名2** (带默认值):
```java
public static <T, V extends Comparable<? super V>> V getSumValue(Collection<T> from,
                                                                 Function<T, V> valueFunc,
                                                                 BinaryOperator<V> accumulator,
                                                                 V defaultValue)
```

**作用**: 对集合中的某个字段求和

**使用示例**:
```java
// 示例1：计算所有商品的总价格
List<Product> products = getProducts();
BigDecimal totalPrice = CollectionUtils.getSumValue(
    products,
    Product::getPrice,
    BigDecimal::add
);

// 示例2：计算总库存（Integer）
Integer totalStock = CollectionUtils.getSumValue(
    products,
    Product::getStock,
    Integer::sum
);

// 示例3：带默认值
BigDecimal total = CollectionUtils.getSumValue(
    products,
    Product::getPrice,
    BigDecimal::add,
    BigDecimal.ZERO  // 如果列表为空，返回 0
);
```

---

### 3.9 集合比较方法

#### 3.9.1 diffList - 对比新旧列表差异

**方法签名**:
```java
public static <T> List<List<T>> diffList(Collection<T> oldList,
                                        Collection<T> newList,
                                        BiFunction<T, T, Boolean> sameFunc)
```

**作用**: 对比新旧两个列表，找出新增、修改、删除的数据

**返回值**: `List<List<T>>`，包含 3 个子列表
- `result.get(0)`: 需要新增的数据（在 newList 中有，在 oldList 中没有）
- `result.get(1)`: 需要修改的数据（在两个列表中都有）
- `result.get(2)`: 需要删除的数据（在 oldList 中有，在 newList 中没有）

**为什么封装**:
- 简化增量更新的逻辑
- 自动识别新增、修改、删除的数据
- 避免手动循环比对

**使用示例**:
```java
// 示例：对比用户角色的变化
List<UserRole> oldRoles = getOldUserRoles(userId);  // 数据库中的旧数据
List<UserRole> newRoles = getNewUserRoles(userId);  // 前端传来的新数据

List<List<UserRole>> diff = CollectionUtils.diffList(
    oldRoles,
    newRoles,
    (old, newRole) -> old.getRoleId().equals(newRole.getRoleId())  // 判断是否同一条数据
);

List<UserRole> toCreate = diff.get(0);  // 需要新增的角色
List<UserRole> toUpdate = diff.get(1);  // 需要更新的角色
List<UserRole> toDelete = diff.get(2);  // 需要删除的角色

// 执行相应的数据库操作
if (!toCreate.isEmpty()) {
    userRoleMapper.batchInsert(toCreate);
}
if (!toUpdate.isEmpty()) {
    userRoleMapper.batchUpdate(toUpdate);
}
if (!toDelete.isEmpty()) {
    userRoleMapper.batchDelete(toDelete);
}
```

**项目实际使用场景1**:
```java
// ashore-module-mall/DeliveryExpressTemplateServiceImpl.java:90
// 对比快递模板包邮配置的变化
List<DeliveryExpressTemplateFreeDO> oldList =
    expressTemplateFreeMapper.selectListByTemplateId(templateId);
List<DeliveryExpressTemplateFreeDO> newList =
    INSTANCE.convertTemplateFreeList(templateId, frees);

List<List<DeliveryExpressTemplateFreeDO>> diffList =
    CollectionUtils.diffList(oldList, newList,
        (oldVal, newVal) -> ObjectUtil.equal(oldVal.getId(), newVal.getId()));

// 批量添加、修改、删除
if (CollUtil.isNotEmpty(diffList.get(0))) {
    expressTemplateFreeMapper.insertBatch(diffList.get(0)); // 新增
}
if (CollUtil.isNotEmpty(diffList.get(1))) {
    expressTemplateFreeMapper.updateBatch(diffList.get(1)); // 更新
}
if (CollUtil.isNotEmpty(diffList.get(2))) {
    expressTemplateFreeMapper.deleteByIds(
        convertList(diffList.get(2), DeliveryExpressTemplateFreeDO::getId)); // 删除
}
```

**项目实际使用场景2**:
```java
// ashore-module-mall/DiscountActivityServiceImpl.java:102
// 对比限时折扣商品列表的变化
List<DiscountProductDO> oldList =
    discountProductMapper.selectListByActivityId(activity.getId());

List<List<DiscountProductDO>> diffList =
    CollectionUtils.diffList(oldList, newList, (oldVal, newVal) -> {
        boolean same = ObjectUtil.equal(oldVal.getSkuId(), newVal.getSkuId());
        if (same) {
            newVal.setId(oldVal.getId()); // 保留原ID
        }
        return same;
    });

// 批量添加、修改、删除
if (CollUtil.isNotEmpty(diffList.get(0))) {
    discountProductMapper.insertBatch(diffList.get(0));
}
if (CollUtil.isNotEmpty(diffList.get(1))) {
    discountProductMapper.updateBatch(diffList.get(1));
}
if (CollUtil.isNotEmpty(diffList.get(2))) {
    discountProductMapper.deleteByIds(
        convertList(diffList.get(2), DiscountProductDO::getId));
}
```

---

### 3.10 其他实用方法

#### 3.10.1 addIfNotNull - 条件添加元素

**方法签名**:
```java
public static <T> void addIfNotNull(Collection<T> coll, T item)
```

**作用**: 如果元素不为 null，才添加到集合中

**使用示例**:
```java
// 示例：构建查询条件列表
List<Long> deptIds = new ArrayList<>();
CollectionUtils.addIfNotNull(deptIds, user.getDeptId());  // 只有不为null才添加
CollectionUtils.addIfNotNull(deptIds, user.getParentDeptId());
```

**项目实际使用**:
```java
// ashore-module-system/PermissionServiceImpl.java:311
// 情况三，DEPT_ONLY - 仅本部门
if (Objects.equals(role.getDataScope(), DataScopeEnum.DEPT_ONLY.getScope())) {
    CollectionUtils.addIfNotNull(result.getDeptIds(), userDeptId.get());
    continue;
}
```

---

#### 3.10.2 singleton - 创建单元素集合

**方法签名**:
```java
public static <T> Collection<T> singleton(T obj)
```

**作用**: 创建只包含一个元素的集合（如果元素为 null 则返回空集合）

**使用示例**:
```java
// 示例：包装单个元素为集合
Long deptId = 1L;
Collection<Long> deptIds = CollectionUtils.singleton(deptId);

// 对比原生写法
Collection<Long> deptIds = deptId != null ?
    Collections.singleton(deptId) : Collections.emptyList();
```

**项目实际使用**:
```java
// ashore-module-system/AdminUserServiceImpl.java:370
// 校验部门处于开启状态（传递单个部门ID，包装为集合）
deptService.validateDeptList(CollectionUtils.singleton(deptId));
```

---

#### 3.10.3 mergeValuesFromMap - 合并Map中的所有值

**方法签名**:
```java
public static <K, V> List<V> mergeValuesFromMap(Map<K, List<V>> map)
```

**作用**: 将 `Map<K, List<V>>` 中所有的 List 合并为一个 List

**使用示例**:
```java
// 示例：将按部门分组的用户合并为一个列表
Map<Long, List<User>> deptUserMap = getDeptUserMap();
List<User> allUsers = CollectionUtils.mergeValuesFromMap(deptUserMap);
```

---

#### 3.10.4 convertPage - 分页数据转换

**方法签名**:
```java
public static <T, U> PageResult<U> convertPage(PageResult<T> from, Function<T, U> func)
```

**作用**: 转换分页对象中的数据列表

**使用示例**:
```java
// 示例：将分页的DO转换为分页的VO
PageResult<UserDO> userPage = userMapper.selectPage(pageReqVO);
PageResult<UserVO> userVOPage = CollectionUtils.convertPage(userPage, user -> {
    UserVO vo = new UserVO();
    BeanUtil.copyProperties(user, vo);
    return vo;
});
```

---

## 四、ArrayUtils - 数组工具类

### 4.1 类的整体介绍

`ArrayUtils` 提供数组操作的便捷方法，主要用于数组与集合的互转、安全访问数组元素、数组合并等操作。

**依赖库**: Hutool (`cn.hutool.core.util.ArrayUtil`)

**为什么要二次封装**:
- 提供更安全的数组访问方式
- 简化数组与集合的转换
- 与 `CollectionUtils` 配合使用

---

### 4.2 方法详解

#### 4.2.1 toArray - 集合转数组

**方法签名1** (保持元素类型):
```java
public static <T> T[] toArray(Collection<T> from)
```

**方法签名2** (转换元素类型):
```java
public static <T, V> V[] toArray(Collection<T> from, Function<T, V> mapper)
```

**作用**: 将集合转换为数组

**为什么封装**:
- 自动推断数组元素类型，避免手动指定
- 支持转换时映射元素
- 空集合安全

**使用示例**:
```java
// 示例1：集合转数组
List<String> nameList = Arrays.asList("张三", "李四", "王五");
String[] nameArray = ArrayUtils.toArray(nameList);
// 结果：["张三", "李四", "王五"]

// 示例2：转换时映射元素
List<User> users = getUserList();
Long[] userIdArray = ArrayUtils.toArray(users, User::getId);
// 结果：[1L, 2L, 3L]
```

**项目实际使用**:
```java
// ashore-module-system/TencentSmsClient.java:94
// 将模板参数列表转换为字符串数组
body.put("TemplateParamSet", ArrayUtils.toArray(templateParams,
    param -> String.valueOf(param.getValue())));
```

---

#### 4.2.2 get - 安全获取数组元素

**方法签名**:
```java
public static <T> T get(T[] array, int index)
```

**作用**: 安全地获取数组元素，避免数组越界异常

**为什么封装**:
- 原生数组访问 `array[index]` 会抛出 `ArrayIndexOutOfBoundsException`
- 封装后返回 null 而不是抛异常

**使用示例**:
```java
// 示例：安全获取数组元素
String[] names = {"张三", "李四"};
String first = ArrayUtils.get(names, 0);  // "张三"
String third = ArrayUtils.get(names, 2);  // null（不会抛异常）

// 对比原生写法
String third = names.length > 2 ? names[2] : null;
```

**项目实际使用**:
```java
// ashore-framework/LambdaQueryWrapperX.java:98
// 安全获取时间范围数组的开始和结束时间
public LambdaQueryWrapperX<T> betweenIfPresent(SFunction<T, ?> column, Object[] values) {
    Object val1 = ArrayUtils.get(values, 0); // 开始时间
    Object val2 = ArrayUtils.get(values, 1); // 结束时间
    return betweenIfPresent(column, val1, val2);
}
```

---

#### 4.2.3 append - 合并数组

**方法签名**:
```java
@SafeVarargs
public static <T> Consumer<T>[] append(Consumer<T> object, Consumer<T>... newElements)
```

**作用**: 将一个对象和一个数组合并成一个新数组

**使用示例**:
```java
// 示例：合并消费者数组
Consumer<User> logger = user -> log.info("User: {}", user);
Consumer<User> validator = user -> validate(user);
Consumer<User> saver = user -> save(user);

Consumer<User>[] consumers = ArrayUtils.append(logger, validator, saver);
// 结果：[logger, validator, saver]
```

---

### 4.3 项目中的实际使用总结

ArrayUtils 在项目中主要用于以下场景：

1. **MyBatis 动态查询**: 安全获取查询条件数组的元素
   ```java
   // ashore-framework/LambdaQueryWrapperX.java
   Object val1 = ArrayUtils.get(values, 0);
   Object val2 = ArrayUtils.get(values, 1);
   ```

2. **第三方 API 参数转换**: 集合转数组
   ```java
   // ashore-module-system/TencentSmsClient.java
   body.put("TemplateParamSet", ArrayUtils.toArray(templateParams,
       param -> String.valueOf(param.getValue())));
   ```

3. **接口反射**: 判断类是否实现了接口
   ```java
   // ashore-framework/Knife4jOpenApiCustomizer.java
   Class<?>[] interfaces = clazz.getInterfaces();
   if (ArrayUtils.isNotEmpty(interfaces)) {
       for (Class<?> interfaceClazz : interfaces) {
           // ...
       }
   }
   ```

---

## 五、MapUtils - Map工具类

### 5.1 类的整体介绍

`MapUtils` 提供 Map 操作的便捷方法，主要用于安全地从 Map 中查找并处理值，以及优化 Map 的创建。

**依赖库**:
- Hutool (`cn.hutool.core.collection.CollUtil`)
- Guava (`com.google.common.collect`)

---

### 5.2 方法详解

#### 5.2.1 findAndThen - 查找并执行

**方法签名**:
```java
public static <K, V> void findAndThen(Map<K, V> map, K key, Consumer<V> consumer)
```

**作用**: 从 Map 中查找 key 对应的 value，如果存在且不为 null，则执行 consumer 逻辑

**为什么封装**:
- 简化 `map.get(key)` 后的 null 检查
- 避免 NPE
- 代码更简洁优雅

**加强了什么功能**:
- 原生 `map.get(key)` 返回 null 需要手动判断
- 封装后自动处理 null，只有值存在时才执行消费逻辑

**使用示例**:
```java
// 示例1：填充产品分类名称
Map<Long, Category> categoryMap = getCategoryMap();
List<Product> products = getProducts();

products.forEach(product -> {
    // 从 Map 中查找并设置分类名称（自动处理 null）
    MapUtils.findAndThen(categoryMap, product.getCategoryId(),
        category -> product.setCategoryName(category.getName()));
});

// 对比原生写法（冗长）
products.forEach(product -> {
    Category category = categoryMap.get(product.getCategoryId());
    if (category != null) {
        product.setCategoryName(category.getName());
    }
});

// 示例2：填充用户信息
Map<Long, User> userMap = getUserMap();
List<Order> orders = getOrders();

orders.forEach(order -> {
    MapUtils.findAndThen(userMap, order.getUserId(), user -> {
        order.setUserName(user.getName());
        order.setUserMobile(user.getMobile());
    });
});
```

**项目实际使用场景1**:
```java
// ashore-module-erp/ErpProductServiceImpl.java:130
// 批量获取产品分类和单位映射
Map<Long, ErpProductCategoryDO> categoryMap = productCategoryService.getProductCategoryMap(
        convertSet(list, ErpProductDO::getCategoryId));
Map<Long, ErpProductUnitDO> unitMap = productUnitService.getProductUnitMap(
        convertSet(list, ErpProductDO::getUnitId));

return BeanUtils.toBean(list, ErpProductRespVO.class, product -> {
    // 从Map中查找并设置分类名称
    MapUtils.findAndThen(categoryMap, product.getCategoryId(),
            category -> product.setCategoryName(category.getName()));
    // 从Map中查找并设置单位名称
    MapUtils.findAndThen(unitMap, product.getUnitId(),
            unit -> product.setUnitName(unit.getName()));
});
```

**项目实际使用场景2**:
```java
// ashore-module-erp/ErpStockOutController.java:112
// 填充出库单明细的产品信息
Map<Long, ErpProductRespVO> productMap = productService.getProductVOMap(
        convertSet(stockOutItemList, ErpStockOutItemDO::getProductId));

return success(BeanUtils.toBean(stockOut, ErpStockOutRespVO.class, stockOutVO ->
        stockOutVO.setItems(BeanUtils.toBean(stockOutItemList, ErpStockOutRespVO.Item.class, item -> {
            ErpStockDO stock = stockService.getStock(item.getProductId(), item.getWarehouseId());
            item.setStockCount(stock != null ? stock.getCount() : BigDecimal.ZERO);
            // 安全填充产品信息
            MapUtils.findAndThen(productMap, item.getProductId(), product ->
                item.setProductName(product.getName())
                    .setProductBarCode(product.getBarCode())
                    .setProductUnitName(product.getUnitName()));
        }))
));
```

**典型应用场景 - 避免 N+1 查询**:
```java
// 场景：订单列表需要填充用户和商品信息

// ❌ 错误做法（N+1 查询）
List<Order> orders = orderMapper.selectList();
orders.forEach(order -> {
    User user = userMapper.selectById(order.getUserId());  // N 次查询
    order.setUserName(user.getName());

    Product product = productMapper.selectById(order.getProductId());  // N 次查询
    order.setProductName(product.getName());
});

// ✅ 正确做法（批量查询 + Map 关联）
List<Order> orders = orderMapper.selectList();

// 批量查询用户和商品（2次查询）
Map<Long, User> userMap = CollectionUtils.convertMap(
    userMapper.selectByIds(CollectionUtils.convertSet(orders, Order::getUserId)),
    User::getId
);
Map<Long, Product> productMap = CollectionUtils.convertMap(
    productMapper.selectByIds(CollectionUtils.convertSet(orders, Order::getProductId)),
    Product::getId
);

// 填充信息（O(1) 查找）
orders.forEach(order -> {
    MapUtils.findAndThen(userMap, order.getUserId(),
        user -> order.setUserName(user.getName()));
    MapUtils.findAndThen(productMap, order.getProductId(),
        product -> order.setProductName(product.getName()));
});
```

---

#### 5.2.2 getList - 从Multimap中批量获取值

**方法签名**:
```java
public static <K, V> List<V> getList(Multimap<K, V> multimap, Collection<K> keys)
```

**作用**: 从 Guava 的 Multimap 中，根据多个 key 批量获取所有 value

**使用示例**:
```java
// 示例：从 Multimap 中批量获取数据
Multimap<String, String> rolePermissionMap = HashMultimap.create();
rolePermissionMap.put("admin", "user:create");
rolePermissionMap.put("admin", "user:update");
rolePermissionMap.put("editor", "article:edit");

List<String> adminPermissions = MapUtils.getList(rolePermissionMap,
    Arrays.asList("admin", "editor"));
// 结果：["user:create", "user:update", "article:edit"]
```

---

#### 5.2.3 convertMap - KeyValue列表转Map

**方法签名**:
```java
public static <K, V> Map<K, V> convertMap(List<KeyValue<K, V>> keyValues)
```

**作用**: 将 KeyValue 列表转换为 Map

**使用示例**:
```java
// 示例：将配置列表转换为 Map
List<KeyValue<String, String>> configList = Arrays.asList(
    new KeyValue<>("db.host", "localhost"),
    new KeyValue<>("db.port", "3306")
);
Map<String, String> configMap = MapUtils.convertMap(configList);
// 结果：{"db.host": "localhost", "db.port": "3306"}
```

---

### 5.3 项目中的实际使用总结

MapUtils 在项目中主要用于以下场景：

1. **VO 转换时填充关联数据**: 批量查询关联表后，通过 Map 快速填充，避免 N+1 查询
   ```java
   // ERP 产品列表填充分类名称和单位名称
   MapUtils.findAndThen(categoryMap, product.getCategoryId(),
       category -> product.setCategoryName(category.getName()));
   ```

2. **主从表数据组装**: 查询主表和从表后，通过 Map 关联组装完整数据
   ```java
   // 出库单填充产品信息
   MapUtils.findAndThen(productMap, item.getProductId(), product ->
       item.setProductName(product.getName()));
   ```

3. **性能优化**: 预先创建指定容量的 HashMap，避免扩容开销
   ```java
   // Excel 列宽缓存
   private final Map<Integer, Map<Integer, Integer>> cache =
       MapUtils.newHashMapWithExpectedSize(8);
   ```

---

## 六、SetUtils - Set工具类

### 6.1 类的整体介绍

`SetUtils` 提供快速创建 Set 集合的便捷方法，主要用于定义常量集合、创建临时集合等。

**依赖库**: Hutool (`cn.hutool.core.collection.CollUtil`)

---

### 6.2 方法详解

#### 6.2.1 asSet - 创建Set集合

**方法签名**:
```java
@SafeVarargs
public static <T> Set<T> asSet(T... objs)
```

**作用**: 将可变参数转换为 HashSet

**为什么封装**:
- 简化 Set 的创建
- 代码更简洁
- 与 `Arrays.asList()` 类似，但返回 Set

**使用示例**:
```java
// 示例1：创建字符串集合
Set<String> allowedStatus = SetUtils.asSet("PENDING", "APPROVED", "REJECTED");

// 示例2：创建数字集合
Set<Integer> validCodes = SetUtils.asSet(200, 201, 204);

// 对比原生写法
Set<String> allowedStatus = new HashSet<>(Arrays.asList("PENDING", "APPROVED", "REJECTED"));
```

**项目实际使用场景1**:
```java
// ashore-module-mp/MpAutoReplyDO.java:34
// 定义公众号自动回复支持的消息类型
public static Set<String> REQUEST_MESSAGE_TYPE = SetUtils.asSet(
    WxConsts.XmlMsgType.TEXT,
    WxConsts.XmlMsgType.IMAGE,
    WxConsts.XmlMsgType.VOICE,
    WxConsts.XmlMsgType.VIDEO,
    WxConsts.XmlMsgType.SHORTVIDEO,
    WxConsts.XmlMsgType.LOCATION,
    WxConsts.XmlMsgType.LINK
);
```

**项目实际使用场景2**:
```java
// ashore-framework/GlobalExceptionHandler.java:63
// 忽略的 ServiceException 错误提示，避免打印过多 logger
public static final Set<String> IGNORE_ERROR_MESSAGES = SetUtils.asSet("无效的刷新令牌");
```

**项目实际使用场景3**:
```java
// ashore-gateway/ProjectReactor.java:36
// 定义项目中允许的文件类型白名单
private static final Set<String> WHITE_FILE_TYPES = SetUtils.asSet(
    "gif", "jpg", "svg", "png", // 图片
    "eot", "ttf", "woff", "woff2", // 字体
    "css", "js", "html", "ico" // 前端资源
);
```

---

### 6.3 项目中的实际使用总结

SetUtils 在项目中主要用于以下场景：

1. **定义常量集合**: 定义业务规则允许的值集合
   ```java
   public static Set<String> ALLOWED_STATUS = SetUtils.asSet("ACTIVE", "PENDING");
   ```

2. **配置白名单/黑名单**: 定义允许或禁止的值
   ```java
   private static final Set<String> WHITE_FILE_TYPES = SetUtils.asSet("jpg", "png", "pdf");
   ```

3. **全局异常处理**: 定义需要忽略的异常消息
   ```java
   public static final Set<String> IGNORE_ERROR_MESSAGES = SetUtils.asSet("无效的刷新令牌");
   ```

---

## 七、实战场景总结

### 7.1 常见业务场景最佳实践

#### 场景1：用户列表转VO，并过滤掉未激活的用户

```java
// 需求：查询用户列表，转换为VO，只返回激活状态的用户

// 方式1：先过滤再转换（推荐，减少转换次数）
List<UserDO> userDOs = userMapper.selectList();
List<UserVO> activeUserVOs = CollectionUtils.convertList(
    userDOs,
    this::convertToVO,  // 转换方法
    user -> user.getStatus() == 1  // 过滤条件
);

// 方式2：先转换再过滤
List<UserVO> userVOs = CollectionUtils.convertList(userDOs, this::convertToVO);
List<UserVO> activeUserVOs = CollectionUtils.filterList(userVOs, vo -> vo.getStatus() == 1);
```

---

#### 场景2：批量查询并构建映射表（避免N+1查询）

```java
// 需求：订单列表需要填充用户名称

// ❌ 错误做法（N+1 查询，性能差）
List<Order> orders = orderMapper.selectList();
orders.forEach(order -> {
    User user = userMapper.selectById(order.getUserId());  // 每个订单都查一次
    order.setUserName(user.getName());
});

// ✅ 正确做法（批量查询，性能好）
List<Order> orders = orderMapper.selectList();

// 1. 提取所有用户ID（去重）
Set<Long> userIds = CollectionUtils.convertSet(orders, Order::getUserId);

// 2. 批量查询用户
List<User> users = userMapper.selectByIds(userIds);

// 3. 构建 ID -> User 的映射
Map<Long, User> userMap = CollectionUtils.convertMap(users, User::getId);

// 4. 填充订单的用户信息（O(1) 查找）
orders.forEach(order -> {
    MapUtils.findAndThen(userMap, order.getUserId(), user -> {
        order.setUserName(user.getName());
        order.setUserMobile(user.getMobile());
    });
});
```

---

#### 场景3：主从表数据组装

```java
// 需求：查询订单及其订单项

// 1. 查询订单列表
List<Order> orders = orderMapper.selectList();
List<Long> orderIds = CollectionUtils.convertList(orders, Order::getId);

// 2. 批量查询订单项
List<OrderItem> items = orderItemMapper.selectByOrderIds(orderIds);

// 3. 按订单ID分组订单项
Map<Long, List<OrderItem>> orderItemMap =
    CollectionUtils.convertMultiMap(items, OrderItem::getOrderId);

// 4. 填充订单的订单项
orders.forEach(order -> {
    List<OrderItem> orderItems = orderItemMap.get(order.getId());
    order.setItems(orderItems != null ? orderItems : Collections.emptyList());
});

return orders;
```

---

#### 场景4：统计每个部门的用户数

```java
// 需求：统计每个部门的用户数量

List<User> users = getUserList();

// 1. 按部门分组
Map<Long, List<User>> deptUserMap =
    CollectionUtils.convertMultiMap(users, User::getDeptId);

// 2. 统计每个部门的人数
Map<Long, Integer> deptCountMap = new HashMap<>();
deptUserMap.forEach((deptId, userList) -> {
    deptCountMap.put(deptId, userList.size());
});

// 或者使用 Stream API
Map<Long, Long> deptCountMap2 = users.stream()
    .collect(Collectors.groupingBy(User::getDeptId, Collectors.counting()));
```

---

#### 场景5：配置更新（增量更新）

```java
// 需求：更新用户角色，支持新增、修改、删除

@Transactional
public void updateUserRoles(Long userId, List<UserRoleSaveReqVO> newRoles) {
    // 1. 查询数据库中的旧数据
    List<UserRole> oldRoles = userRoleMapper.selectByUserId(userId);

    // 2. 将前端传来的VO转换为DO
    List<UserRole> newRoleList = BeanUtils.toBean(newRoles, UserRole.class);
    newRoleList.forEach(role -> role.setUserId(userId));

    // 3. 对比新旧数据
    List<List<UserRole>> diff = CollectionUtils.diffList(
        oldRoles,
        newRoleList,
        (old, newRole) -> old.getRoleId().equals(newRole.getRoleId())  // 判断是否同一条数据
    );

    List<UserRole> toCreate = diff.get(0);  // 需要新增的
    List<UserRole> toUpdate = diff.get(1);  // 需要更新的
    List<UserRole> toDelete = diff.get(2);  // 需要删除的

    // 4. 批量执行数据库操作
    if (!toCreate.isEmpty()) {
        userRoleMapper.batchInsert(toCreate);
    }
    if (!toUpdate.isEmpty()) {
        userRoleMapper.batchUpdate(toUpdate);
    }
    if (!toDelete.isEmpty()) {
        userRoleMapper.batchDelete(
            CollectionUtils.convertList(toDelete, UserRole::getId)
        );
    }
}
```

---

### 7.2 性能优化技巧

#### 技巧1：减少数据库查询次数

```java
// ❌ 低效：每个订单查一次用户（N+1 查询）
orders.forEach(order -> {
    User user = userMapper.selectById(order.getUserId());
    order.setUserName(user.getName());
});

// ✅ 高效：批量查询（1次查询）
Set<Long> userIds = CollectionUtils.convertSet(orders, Order::getUserId);
Map<Long, User> userMap = CollectionUtils.convertMap(
    userMapper.selectByIds(userIds),
    User::getId
);
orders.forEach(order ->
    MapUtils.findAndThen(userMap, order.getUserId(),
        user -> order.setUserName(user.getName()))
);
```

---

#### 技巧2：先过滤再转换

```java
// ❌ 低效：转换后再过滤（所有元素都转换了）
List<UserVO> allVOs = CollectionUtils.convertList(users, this::convertToVO);
List<UserVO> activeVOs = CollectionUtils.filterList(allVOs, vo -> vo.getStatus() == 1);

// ✅ 高效：先过滤再转换（只转换需要的元素）
List<UserVO> activeVOs = CollectionUtils.convertList(
    users,
    this::convertToVO,
    user -> user.getStatus() == 1
);
```

---

#### 技巧3：使用 Set 去重，避免重复查询

```java
// ❌ 低效：List 可能包含重复的ID
List<Long> userIds = CollectionUtils.convertList(orders, Order::getUserId);
List<User> users = userMapper.selectByIds(userIds);  // 可能查询了重复数据

// ✅ 高效：Set 自动去重
Set<Long> userIds = CollectionUtils.convertSet(orders, Order::getUserId);
List<User> users = userMapper.selectByIds(userIds);
```

---

### 7.3 注意事项和最佳实践

#### 注意事项1：所有方法都是静态的
```java
// ✅ 正确：静态调用
List<String> names = CollectionUtils.convertList(users, User::getName);

// ❌ 错误：不能实例化
CollectionUtils utils = new CollectionUtils();  // 编译错误
```

---

#### 注意事项2：自动过滤 null
```java
List<User> users = Arrays.asList(
    new User(1L, "张三"),
    null,
    new User(2L, "李四")
);

// convertList 会自动过滤 null 元素
List<String> names = CollectionUtils.convertList(users, User::getName);
// 结果：["张三", "李四"]（null 被过滤了）
```

---

#### 注意事项3：空集合安全
```java
List<User> users = null;

// 传入 null 或空集合会返回空集合，不会抛异常
List<String> names = CollectionUtils.convertList(users, User::getName);
// 结果：[]（空列表）

// 对比原生 Stream（会抛 NPE）
List<String> names = users.stream().map(User::getName).collect(Collectors.toList());
// 抛出 NullPointerException
```

---

#### 注意事项4：diffList 的 sameFunc 应该判断"标识"而非"完全相等"
```java
// ❌ 错误：判断对象完全相等（无法识别修改）
List<List<User>> diff = CollectionUtils.diffList(
    oldUsers,
    newUsers,
    (old, newUser) -> old.equals(newUser)  // 错误！
);

// ✅ 正确：判断标识（ID）是否相同
List<List<User>> diff = CollectionUtils.diffList(
    oldUsers,
    newUsers,
    (old, newUser) -> old.getId().equals(newUser.getId())  // 正确！
);
```

---

#### 最佳实践1：使用方法引用简化代码
```java
// ✅ 推荐：方法引用（简洁）
List<String> names = CollectionUtils.convertList(users, User::getName);

// 可以但不推荐：Lambda 表达式（冗长）
List<String> names = CollectionUtils.convertList(users, user -> user.getName());
```

---

#### 最佳实践2：复杂转换使用 Lambda 表达式
```java
// 复杂逻辑必须用 Lambda
List<UserVO> vos = CollectionUtils.convertList(users, user -> {
    UserVO vo = new UserVO();
    vo.setId(user.getId());
    vo.setName(user.getName());
    vo.setAge(user.getAge());
    vo.setDeptName(deptMap.get(user.getDeptId()).getName());  // 关联查询
    return vo;
});
```

---

#### 最佳实践3：链式调用（函数式编程风格）
```java
// 示例：多步骤处理
List<String> result = CollectionUtils.convertList(
    CollectionUtils.filterList(users, user -> user.getAge() >= 18),  // 先过滤
    User::getName  // 再转换
);

// 或者使用 convertList 的重载方法（更简洁）
List<String> result = CollectionUtils.convertList(
    users,
    User::getName,
    user -> user.getAge() >= 18
);
```

---

### 7.4 学习建议

1. **从简单方法开始**: 先掌握 `convertList`、`filterList`、`convertMap`、`convertSet`
2. **理解函数式接口**: 重点学习 `Function`、`Predicate`、`BiFunction` 的用法
3. **对比传统写法**: 体会工具类如何简化代码
4. **在实际项目中使用**: 多练习才能熟练掌握
5. **性能优化意识**: 理解批量查询、Map 关联的优势，避免 N+1 查询

---

## 八、附录

### 8.1 方法速查表

#### CollectionUtils 方法分类

| 分类 | 方法 | 作用 |
|------|------|------|
| **判断** | `containsAny` | 元素是否在数组中 |
| | `isAnyEmpty` | 是否有任一集合为空 |
| | `anyMatch` | 是否有元素满足条件 |
| **过滤** | `filterList` | 条件过滤 |
| | `distinct` | 去重 |
| **转换** | `convertList` | List 转换 |
| | `convertSet` | Set 转换 |
| | `convertMap` | Map 转换 |
| | `convertPage` | 分页转换 |
| **分组** | `convertMultiMap` | 一对多分组（List） |
| | `convertMultiMap2` | 一对多分组（Set） |
| **扁平化** | `convertListByFlatMap` | 嵌套集合拍平为 List |
| | `convertSetByFlatMap` | 嵌套集合拍平为 Set |
| **查找** | `findFirst` | 查找第一个满足条件的 |
| | `getFirst` | 获取第一个元素 |
| | `getMaxValue` | 获取最大值 |
| | `getMinValue` | 获取最小值 |
| **聚合** | `getSumValue` | 求和 |
| **比较** | `diffList` | 对比新旧列表差异 |
| **其他** | `addIfNotNull` | 条件添加元素 |
| | `singleton` | 创建单元素集合 |

---

### 8.2 运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Service、Controller、Converter 等任何地方
- **依赖库**: Hutool、Guava、Spring、Java Stream API
- **设计模式**: 门面模式（封装复杂操作，提供简单接口）

---

**文档版本**: v2.0
**最后更新**: 2025-10-19
**维护者**: ashore 团队
