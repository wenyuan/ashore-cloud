# 日期时间工具类使用指南

## 一、包概览

`date` 包提供了完整的日期时间处理工具类，主要包含两个核心类：

- **DateUtils**: `Date` 类型工具类，提供 Date 与 LocalDateTime 互转、时间判断等功能
- **LocalDateTimeUtils**: `LocalDateTime` 类型工具类，提供时间范围判断、格式化、快捷获取等功能

这两个类相互配合，覆盖了项目中所有的日期时间处理场景。

---

## 二、DateUtils 类详解

### 2.1 类的整体介绍

`DateUtils` 是 `Date` 类型的工具类，主要解决以下问题：

1. **类型转换问题**: Java 8 之后推荐使用 `LocalDateTime`，但很多第三方库（如 Flowable、MyBatis）仍使用 `Date`，需要频繁转换
2. **时间判断简化**: 封装常用的时间判断逻辑（是否过期、是否今天、是否昨天等）
3. **时间构建便捷**: 提供快捷的时间构建方法

### 2.2 核心方法详解

#### `toDate(LocalDateTime date)` - LocalDateTime 转 Date
**作用**: 将 `LocalDateTime` 转换为 `Date`

**参数**:
- `date`: LocalDateTime 对象

**返回值**: Date 对象，如果参数为 null 则返回 null

**使用示例**:
```java
// 示例1：将 LocalDateTime 转为 Date
LocalDateTime now = LocalDateTime.now();
Date date = DateUtils.toDate(now);

// 示例2：用于数据库查询（MyBatis 需要 Date）
LocalDateTime startTime = LocalDateTime.of(2024, 1, 1, 0, 0);
Date startDate = DateUtils.toDate(startTime);
userMapper.selectByCreateTime(startDate);
```

**项目实际使用场景**:
- **BPM 任务查询**: 在 `TaskQueryServiceImpl` 中，将前端传入的 LocalDateTime 转换为 Date 给 Flowable 使用
  ```java
  // ashore-module-bpm/ashore-module-bpm-biz/src/main/java/com/example/ashore/module/bpm/service/task/BpmTaskQueryServiceImpl.java
  Date beginCreateTime = DateUtils.toDate(reqVO.getCreateTime()[0]);
  Date endCreateTime = DateUtils.toDate(reqVO.getCreateTime()[1]);
  taskQuery.taskCreatedAfter(beginCreateTime).taskCreatedBefore(endCreateTime);
  ```

---

#### `toLocalDateTime(Date date)` - Date 转 LocalDateTime
**作用**: 将 `Date` 转换为 `LocalDateTime`

**参数**:
- `date`: Date 对象

**返回值**: LocalDateTime 对象，如果参数为 null 则返回 null

**使用示例**:
```java
// 示例：从数据库查询的 Date 转为 LocalDateTime
Date dbDate = userMapper.getCreateTime();
LocalDateTime localDateTime = DateUtils.toLocalDateTime(dbDate);

// 业务逻辑处理
if (localDateTime.isAfter(LocalDateTime.now().minusDays(7))) {
    // 7天内的数据
}
```

**项目实际使用场景**:
- **MyBatis 查询结果转换**: 数据库返回的 Date 类型转换为 LocalDateTime 进行业务处理

---

#### `isExpired(LocalDateTime time)` - 判断是否过期
**作用**: 判断指定时间是否已过期（是否在当前时间之前）

**参数**:
- `time`: 待判断的时间

**返回值**: true-已过期，false-未过期

**使用示例**:
```java
// 示例1：判断令牌是否过期
LocalDateTime tokenExpireTime = token.getExpireTime();
if (DateUtils.isExpired(tokenExpireTime)) {
    throw new BusinessException("令牌已过期");
}

// 示例2：判断活动是否结束
LocalDateTime activityEndTime = activity.getEndTime();
boolean isEnded = DateUtils.isExpired(activityEndTime);
```

**项目实际使用场景**:
- **OAuth2 令牌过期判断**: 在 `OAuth2TokenServiceImpl` 中判断访问令牌是否过期
  ```java
  // ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/service/oauth2/OAuth2TokenServiceImpl.java
  if (DateUtils.isExpired(accessToken.getExpiresTime())) {
      throw new BusinessException("访问令牌已过期");
  }
  ```

---

#### `isToday(LocalDateTime date)` - 判断是否今天
**作用**: 判断指定时间是否是今天

**参数**:
- `date`: 待判断的时间

**返回值**: true-是今天，false-不是今天

**使用示例**:
```java
// 示例：判断用户是否今天签到过
LocalDateTime lastSignTime = user.getLastSignTime();
if (DateUtils.isToday(lastSignTime)) {
    return "您今天已经签到过了";
}
```

**项目实际使用场景**:
- **会员签到**: 在 `MemberSignInServiceImpl` 中判断用户今天是否已签到
  ```java
  // ashore-module-member/ashore-module-member-biz/src/main/java/com/example/ashore/module/member/service/signin/MemberSignInServiceImpl.java
  MemberSignInRecordDO todayRecord = signInRecordMapper.selectByUserIdAndDay(userId, LocalDate.now());
  if (todayRecord != null && DateUtils.isToday(todayRecord.getCreateTime())) {
      throw new BusinessException("今天已经签到过了");
  }
  ```

---

#### `isYesterday(LocalDateTime date)` - 判断是否昨天
**作用**: 判断指定时间是否是昨天

**参数**:
- `date`: 待判断的时间

**返回值**: true-是昨天，false-不是昨天

**使用示例**:
```java
// 示例：判断用户昨天是否签到
LocalDateTime lastSignTime = user.getLastSignTime();
if (DateUtils.isYesterday(lastSignTime)) {
    // 连续签到天数 +1
    user.setContinuousDays(user.getContinuousDays() + 1);
} else if (!DateUtils.isToday(lastSignTime)) {
    // 断签了，重置为 1
    user.setContinuousDays(1);
}
```

**项目实际使用场景**:
- **会员连续签到**: 判断用户是否连续签到，计算连续签到天数

---

#### `buildTime(int year, int month, int day)` - 构建指定日期
**作用**: 快速构建指定日期（时间为 00:00:00）

**参数**:
- `year`: 年份
- `month`: 月份（1-12）
- `day`: 日（1-31）

**返回值**: Date 对象

**使用示例**:
```java
// 示例1：构建指定日期
Date date = DateUtils.buildTime(2024, 10, 1); // 2024-10-01 00:00:00

// 示例2：查询某天的数据
Date startDate = DateUtils.buildTime(2024, 10, 1);
Date endDate = DateUtils.buildTime(2024, 10, 2);
List<Order> orders = orderMapper.selectBetween(startDate, endDate);
```

---

#### `buildTime(int year, int month, int day, int hour, int minute, int second)` - 构建指定时间
**作用**: 快速构建指定时间（精确到秒）

**参数**:
- `year`: 年份
- `month`: 月份（1-12）
- `day`: 日（1-31）
- `hour`: 小时（0-23）
- `minute`: 分钟（0-59）
- `second`: 秒（0-59）

**返回值**: Date 对象

**使用示例**:
```java
// 示例：构建精确时间
Date deadline = DateUtils.buildTime(2024, 10, 1, 18, 30, 0); // 2024-10-01 18:30:00

// 活动截止时间判断
if (new Date().after(deadline)) {
    throw new BusinessException("活动已结束");
}
```

---

#### `addTime(Duration duration)` - 增加时间
**作用**: 在当前时间基础上增加指定时长

**参数**:
- `duration`: 时长（使用 Java 8 的 Duration）

**返回值**: Date 对象

**使用示例**:
```java
// 示例1：生成30分钟后过期的令牌
Date expireTime = DateUtils.addTime(Duration.ofMinutes(30));
token.setExpireTime(expireTime);

// 示例2：生成7天后过期的验证码
Date expireTime = DateUtils.addTime(Duration.ofDays(7));
verifyCode.setExpireTime(expireTime);

// 示例3：生成2小时后过期的链接
Date expireTime = DateUtils.addTime(Duration.ofHours(2));
```

**项目实际使用场景**:
- **OAuth2 令牌生成**: 设置令牌过期时间
- **验证码过期时间**: 短信/邮箱验证码的有效期

---

#### `max(Date a, Date b)` - 取较大的时间
**作用**: 返回两个时间中较晚的一个

**参数**:
- `a`: 时间1
- `b`: 时间2

**返回值**: 较晚的时间，如果某个为 null 则返回另一个

**使用示例**:
```java
// 示例：获取最后更新时间
Date lastModifiedTime = DateUtils.max(user.getUpdateTime(), user.getPasswordUpdateTime());
```

---

#### `max(LocalDateTime a, LocalDateTime b)` - 取较大的时间（LocalDateTime版本）
**作用**: 返回两个时间中较晚的一个（LocalDateTime 版本）

**参数**:
- `a`: 时间1
- `b`: 时间2

**返回值**: 较晚的时间，如果某个为 null 则返回另一个

**使用示例**:
```java
// 示例：获取最新的操作时间
LocalDateTime latestTime = DateUtils.max(order.getCreateTime(), order.getUpdateTime());
```

---

## 三、LocalDateTimeUtils 类详解

### 3.1 类的整体介绍

`LocalDateTimeUtils` 是 `LocalDateTime` 类型的工具类，主要解决以下问题：

1. **时间解析增强**: 智能解析多种格式的时间字符串
2. **时间范围判断**: 判断时间是否在某个范围内、是否重叠等
3. **时间计算**: 快捷获取月初月末、今天、昨天等
4. **统计报表支持**: 生成按天/周/月/季度/年的时间范围列表

### 3.2 核心方法详解

#### `parse(String time)` - 智能解析时间字符串
**作用**: 智能解析时间字符串，支持多种格式

**参数**:
- `time`: 时间字符串

**返回值**: LocalDateTime 对象

**使用示例**:
```java
// 示例：自动识别多种格式
LocalDateTime time1 = LocalDateTimeUtils.parse("2024-10-01");           // 2024-10-01 00:00:00
LocalDateTime time2 = LocalDateTimeUtils.parse("2024-10-01 18:30:00"); // 2024-10-01 18:30:00
LocalDateTime time3 = LocalDateTimeUtils.parse("2024/10/01");          // 2024-10-01 00:00:00

// 实际应用：前端传入的时间字符串
String timeStr = request.getParameter("createTime");
LocalDateTime createTime = LocalDateTimeUtils.parse(timeStr);
```

**项目实际使用场景**:
- **前端参数解析**: 解析前端传入的各种格式的时间字符串
- **Excel 导入**: 解析 Excel 中的时间字段

---

#### `addTime(Duration duration)` - 增加时间
**作用**: 在当前时间基础上增加指定时长，返回 LocalDateTime

**参数**:
- `duration`: 时长

**返回值**: LocalDateTime 对象

**使用示例**:
```java
// 示例：生成过期时间
LocalDateTime expireTime = LocalDateTimeUtils.addTime(Duration.ofHours(2));
```

**项目实际使用场景**:
- **IoT 设备令牌**: 在 `DeviceServiceImpl` 中生成设备令牌的过期时间
  ```java
  // ashore-module-iot/ashore-module-iot-biz/src/main/java/com/example/ashore/module/iot/service/device/DeviceServiceImpl.java
  LocalDateTime expireTime = LocalDateTimeUtils.addTime(Duration.ofDays(30));
  device.setTokenExpireTime(expireTime);
  ```

---

#### `minusTime(Duration duration)` - 减少时间
**作用**: 在当前时间基础上减少指定时长

**参数**:
- `duration`: 时长

**返回值**: LocalDateTime 对象

**使用示例**:
```java
// 示例：查询最近7天的数据
LocalDateTime startTime = LocalDateTimeUtils.minusTime(Duration.ofDays(7));
List<Order> orders = orderMapper.selectAfterTime(startTime);
```

---

#### `beforeNow(LocalDateTime date)` - 判断是否在当前时间之前
**作用**: 判断指定时间是否在当前时间之前

**参数**:
- `date`: 待判断的时间

**返回值**: true-在之前，false-在之后或相等

**使用示例**:
```java
// 示例：判断活动是否开始
if (LocalDateTimeUtils.beforeNow(activity.getStartTime())) {
    return "活动尚未开始";
}
```

**项目实际使用场景**:
- **网关令牌校验**: 在 `GatewayAuthFilter` 中判断令牌是否过期
  ```java
  // ashore-gateway/src/main/java/com/example/ashore/gateway/filter/security/GatewayAuthFilter.java
  if (LocalDateTimeUtils.beforeNow(token.getExpireTime())) {
      throw new BusinessException("令牌已过期");
  }
  ```
- **优惠券有效期判断**: 判断优惠券是否过期
  ```java
  // ashore-module-promotion/ashore-module-promotion-biz/src/main/java/com/example/ashore/module/promotion/service/coupon/CouponServiceImpl.java
  if (LocalDateTimeUtils.beforeNow(coupon.getValidEndTime())) {
      throw new BusinessException("优惠券已过期");
  }
  ```

---

#### `afterNow(LocalDateTime date)` - 判断是否在当前时间之后
**作用**: 判断指定时间是否在当前时间之后

**参数**:
- `date`: 待判断的时间

**返回值**: true-在之后，false-在之前或相等

**使用示例**:
```java
// 示例：判断优惠券是否还有效
if (LocalDateTimeUtils.afterNow(coupon.getValidEndTime())) {
    // 优惠券还有效
    applyCoupon(coupon);
}
```

**项目实际使用场景**:
- **优惠券领取**: 判断优惠券是否还在有效期内
- **活动状态判断**: 判断活动是否还在进行中

---

#### `buildTime(int year, int month, int day)` - 构建指定日期
**作用**: 快速构建指定日期的 LocalDateTime（时间为 00:00:00）

**参数**:
- `year`: 年份
- `month`: 月份（1-12）
- `day`: 日（1-31）

**返回值**: LocalDateTime 对象

**使用示例**:
```java
// 示例：构建测试数据
LocalDateTime startTime = LocalDateTimeUtils.buildTime(2024, 1, 1);
LocalDateTime endTime = LocalDateTimeUtils.buildTime(2024, 12, 31);
```

---

#### `buildBetweenTime(...)` - 构建时间范围
**作用**: 快速构建时间范围数组

**参数**:
- `year1, month1, day1`: 开始时间
- `year2, month2, day2`: 结束时间

**返回值**: LocalDateTime[2]，[0]为开始时间，[1]为结束时间

**使用示例**:
```java
// 示例：构建2024年第一季度时间范围
LocalDateTime[] range = LocalDateTimeUtils.buildBetweenTime(2024, 1, 1, 2024, 3, 31);
List<Order> orders = orderMapper.selectBetween(range[0], range[1]);
```

---

#### `isBetween(LocalDateTime startTime, LocalDateTime endTime, Timestamp time)` - 判断时间是否在范围内
**作用**: 判断指定时间（Timestamp）是否在时间范围内

**参数**:
- `startTime`: 开始时间
- `endTime`: 结束时间
- `time`: 待判断的时间

**返回值**: true-在范围内，false-不在范围内

**使用示例**:
```java
// 示例：判断订单创建时间是否在活动期间
boolean isInActivity = LocalDateTimeUtils.isBetween(
    activity.getStartTime(),
    activity.getEndTime(),
    order.getCreateTime()
);
```

---

#### `isBetween(LocalDateTime startTime, LocalDateTime endTime, String time)` - 判断时间字符串是否在范围内
**作用**: 判断指定时间字符串是否在时间范围内

**参数**:
- `startTime`: 开始时间
- `endTime`: 结束时间
- `time`: 待判断的时间字符串

**返回值**: true-在范围内，false-不在范围内

**使用示例**:
```java
// 示例：判断预约时间是否在营业时间内
boolean isOpen = LocalDateTimeUtils.isBetween(
    shop.getOpenTime(),
    shop.getCloseTime(),
    "14:30:00"
);
```

---

#### `isBetween(LocalDateTime startTime, LocalDateTime endTime)` - 判断当前时间是否在范围内
**作用**: 判断当前时间是否在指定时间范围内

**参数**:
- `startTime`: 开始时间
- `endTime`: 结束时间

**返回值**: true-当前时间在范围内，false-不在范围内

**使用示例**:
```java
// 示例：判断活动是否正在进行
if (LocalDateTimeUtils.isBetween(activity.getStartTime(), activity.getEndTime())) {
    // 活动进行中
    return "活动进行中，快来参加";
} else {
    return "活动已结束";
}
```

**项目实际使用场景**:
- **活动状态判断**: 判断秒杀、拼团等活动是否正在进行
- **会员权益判断**: 判断会员是否在有效期内
- **优惠券使用**: 判断优惠券是否在可用时间段内

---

#### `isBetween(String startTime, String endTime)` - 判断当前时间是否在时间段内（仅时间）
**作用**: 判断当前时间是否在指定的时间段内（只比较时分秒，不比较日期）

**参数**:
- `startTime`: 开始时间（格式：HH:mm:ss）
- `endTime`: 结束时间（格式：HH:mm:ss）

**返回值**: true-当前时间在时间段内，false-不在时间段内

**使用示例**:
```java
// 示例：判断是否在营业时间
if (LocalDateTimeUtils.isBetween("09:00:00", "22:00:00")) {
    // 营业中
    return "欢迎光临";
} else {
    return "已打烊";
}

// 示例：判断是否在午休时间
if (LocalDateTimeUtils.isBetween("12:00:00", "14:00:00")) {
    return "午休时间，请稍后再试";
}
```

**项目实际使用场景**:
- **店铺营业时间**: 判断店铺是否在营业时间内
- **客服工作时间**: 判断客服是否在线
- **系统维护时间**: 判断是否在维护时间段

---

#### `isOverlap(LocalTime startTime1, LocalTime endTime1, LocalTime startTime2, LocalTime endTime2)` - 判断时间段是否重叠
**作用**: 判断两个时间段是否有重叠

**参数**:
- `startTime1, endTime1`: 时间段1
- `startTime2, endTime2`: 时间段2

**返回值**: true-重叠，false-不重叠

**使用示例**:
```java
// 示例：判断会议室预约时间是否冲突
LocalTime meetingStart1 = LocalTime.of(14, 0);  // 14:00
LocalTime meetingEnd1 = LocalTime.of(16, 0);    // 16:00
LocalTime meetingStart2 = LocalTime.of(15, 0);  // 15:00
LocalTime meetingEnd2 = LocalTime.of(17, 0);    // 17:00

if (LocalDateTimeUtils.isOverlap(meetingStart1, meetingEnd1, meetingStart2, meetingEnd2)) {
    throw new BusinessException("会议室时间冲突");
}

// 示例：判断排班是否冲突
if (LocalDateTimeUtils.isOverlap(shift1.getStartTime(), shift1.getEndTime(),
                                  shift2.getStartTime(), shift2.getEndTime())) {
    throw new BusinessException("排班时间冲突");
}
```

**项目实际使用场景**:
- **会议室预约**: 检查预约时间是否冲突
- **员工排班**: 检查排班时间是否重叠
- **促销活动**: 检查多个活动时间是否冲突

---

#### `beginOfMonth(LocalDateTime date)` - 获取月初时间
**作用**: 获取指定日期所在月份的开始时间（例如：2024-10-01 00:00:00.000）

**参数**:
- `date`: 指定日期

**返回值**: 月初的 LocalDateTime

**使用示例**:
```java
// 示例1：获取本月第一天
LocalDateTime firstDay = LocalDateTimeUtils.beginOfMonth(LocalDateTime.now());
// 结果：2024-10-01 00:00:00.000

// 示例2：查询本月订单
LocalDateTime monthStart = LocalDateTimeUtils.beginOfMonth(LocalDateTime.now());
LocalDateTime monthEnd = LocalDateTimeUtils.endOfMonth(LocalDateTime.now());
List<Order> monthOrders = orderMapper.selectBetween(monthStart, monthEnd);
```

**项目实际使用场景**:
- **统计报表**: 在各种统计服务中计算月度统计的起始时间
  ```java
  // ashore-module-statistics/ashore-module-statistics-biz/src/main/java/com/example/ashore/module/statistics/service/trade/TradeStatisticsServiceImpl.java
  LocalDateTime monthStart = LocalDateTimeUtils.beginOfMonth(LocalDateTime.now());
  BigDecimal monthRevenue = orderMapper.sumAmountBetween(monthStart, LocalDateTime.now());
  ```

---

#### `endOfMonth(LocalDateTime date)` - 获取月末时间
**作用**: 获取指定日期所在月份的结束时间（例如：2024-10-31 23:59:59.999）

**参数**:
- `date`: 指定日期

**返回值**: 月末的 LocalDateTime

**使用示例**:
```java
// 示例1：获取本月最后一天
LocalDateTime lastDay = LocalDateTimeUtils.endOfMonth(LocalDateTime.now());
// 结果：2024-10-31 23:59:59.999

// 示例2：查询指定月份的所有数据
LocalDateTime monthStart = LocalDateTimeUtils.beginOfMonth(queryDate);
LocalDateTime monthEnd = LocalDateTimeUtils.endOfMonth(queryDate);
List<SalesData> data = salesMapper.selectBetween(monthStart, monthEnd);
```

**项目实际使用场景**:
- **月度统计**: 计算月度数据的截止时间
- **账单生成**: 生成月度账单时确定账单周期

---

#### `getQuarterOfYear(LocalDateTime date)` - 获取季度
**作用**: 获取指定日期所在的季度（1-4）

**参数**:
- `date`: 指定日期

**返回值**: 季度编号（1/2/3/4）

**使用示例**:
```java
// 示例：获取当前季度
int quarter = LocalDateTimeUtils.getQuarterOfYear(LocalDateTime.now());
// 10月 -> 返回 4（第四季度）

// 示例：生成季度报表标题
LocalDateTime reportTime = LocalDateTime.now();
String title = String.format("%d年第%d季度销售报表",
    reportTime.getYear(),
    LocalDateTimeUtils.getQuarterOfYear(reportTime)
);
```

**项目实际使用场景**:
- **季度统计**: 计算季度统计数据
- **报表生成**: 生成季度报表

---

#### `between(LocalDateTime dateTime)` - 计算天数差
**作用**: 计算指定时间到现在相差多少天

**参数**:
- `dateTime`: 指定时间

**返回值**: 相差天数（负数表示指定时间在未来）

**使用示例**:
```java
// 示例1：计算用户注册天数
Long days = LocalDateTimeUtils.between(user.getCreateTime());
if (days >= 30) {
    // 老用户
    giveOldUserReward(user);
}

// 示例2：计算逾期天数
Long overdueDays = LocalDateTimeUtils.between(order.getDeadline());
if (overdueDays > 0) {
    // 已逾期
    BigDecimal fine = calculateFine(overdueDays);
}
```

---

#### `getToday()` - 获取今天的开始时间
**作用**: 获取今天 00:00:00 的时间

**返回值**: 今天的开始时间

**使用示例**:
```java
// 示例：查询今天的订单
LocalDateTime today = LocalDateTimeUtils.getToday();
List<Order> todayOrders = orderMapper.selectAfter(today);

// 示例：判断是否是今天创建的
if (user.getCreateTime().isAfter(LocalDateTimeUtils.getToday())) {
    // 今天注册的新用户
    giveNewUserGift(user);
}
```

**项目实际使用场景**:
- **日统计**: 统计今日数据的起始时间
- **今日榜单**: 查询今日排行榜数据

---

#### `getYesterday()` - 获取昨天的开始时间
**作用**: 获取昨天 00:00:00 的时间

**返回值**: 昨天的开始时间

**使用示例**:
```java
// 示例：查询昨天的订单
LocalDateTime yesterday = LocalDateTimeUtils.getYesterday();
LocalDateTime today = LocalDateTimeUtils.getToday();
List<Order> yesterdayOrders = orderMapper.selectBetween(yesterday, today);
```

---

#### `getMonth()` - 获取本月的开始时间
**作用**: 获取本月1号 00:00:00 的时间

**返回值**: 本月的开始时间

**使用示例**:
```java
// 示例：查询本月订单
LocalDateTime monthStart = LocalDateTimeUtils.getMonth();
List<Order> monthOrders = orderMapper.selectAfter(monthStart);
```

---

#### `getYear()` - 获取本年的开始时间
**作用**: 获取本年1月1日 00:00:00 的时间

**返回值**: 本年的开始时间

**使用示例**:
```java
// 示例：查询本年订单
LocalDateTime yearStart = LocalDateTimeUtils.getYear();
List<Order> yearOrders = orderMapper.selectAfter(yearStart);

// 示例：计算年度销售额
BigDecimal yearRevenue = orderMapper.sumAmountAfter(LocalDateTimeUtils.getYear());
```

---

#### `getDateRangeList(LocalDateTime startTime, LocalDateTime endTime, Integer interval)` - 生成时间范围列表
**作用**: 根据时间间隔生成时间范围列表，用于统计报表

**参数**:
- `startTime`: 开始时间
- `endTime`: 结束时间
- `interval`: 时间间隔（对应 `DateIntervalEnum`）
  - 1: 小时
  - 2: 天
  - 3: 周
  - 4: 月
  - 5: 季度
  - 6: 年

**返回值**: `List<LocalDateTime[]>`，每个元素是一个时间范围 [开始, 结束]

**使用示例**:
```java
// 示例1：生成按天统计的时间范围
LocalDateTime start = LocalDateTime.of(2024, 10, 1, 0, 0);
LocalDateTime end = LocalDateTime.of(2024, 10, 7, 23, 59);
List<LocalDateTime[]> dayRanges = LocalDateTimeUtils.getDateRangeList(start, end, 2);
// 结果：
// [[2024-10-01 00:00, 2024-10-01 23:59:59.999],
//  [2024-10-02 00:00, 2024-10-02 23:59:59.999],
//  ...
//  [2024-10-07 00:00, 2024-10-07 23:59:59.999]]

// 遍历每个时间范围进行统计
for (LocalDateTime[] range : dayRanges) {
    Long count = orderMapper.countBetween(range[0], range[1]);
    // 保存统计结果
}

// 示例2：生成按月统计的时间范围
List<LocalDateTime[]> monthRanges = LocalDateTimeUtils.getDateRangeList(
    LocalDateTime.of(2024, 1, 1, 0, 0),
    LocalDateTime.of(2024, 12, 31, 23, 59),
    4  // 按月
);
// 结果：12个月的时间范围
```

**项目实际使用场景**:
- **销售统计**: 在 `TradeStatisticsServiceImpl` 中生成销售趋势图的时间范围
  ```java
  // ashore-module-statistics/ashore-module-statistics-biz/src/main/java/com/example/ashore/module/statistics/service/trade/TradeStatisticsServiceImpl.java
  List<LocalDateTime[]> ranges = LocalDateTimeUtils.getDateRangeList(startTime, endTime, interval);
  List<StatisticsData> result = new ArrayList<>();
  for (LocalDateTime[] range : ranges) {
      BigDecimal amount = orderMapper.sumAmountBetween(range[0], range[1]);
      result.add(new StatisticsData(range[0], amount));
  }
  ```
- **用户增长统计**: 统计用户注册趋势
- **商品销量统计**: 统计商品销量变化

---

#### `formatDateRange(LocalDateTime startTime, LocalDateTime endTime, Integer interval)` - 格式化时间范围
**作用**: 根据时间间隔格式化时间范围为可读字符串

**参数**:
- `startTime`: 开始时间
- `endTime`: 结束时间
- `interval`: 时间间隔

**返回值**: 格式化后的字符串

**使用示例**:
```java
// 示例：格式化统计维度
LocalDateTime time = LocalDateTime.of(2024, 10, 15, 14, 30);

String hour = LocalDateTimeUtils.formatDateRange(time, time, 1);   // "2024-10-15 14:30"
String day = LocalDateTimeUtils.formatDateRange(time, time, 2);    // "2024-10-15"
String week = LocalDateTimeUtils.formatDateRange(time, time, 3);   // "2024-10-15(第 42 周)"
String month = LocalDateTimeUtils.formatDateRange(time, time, 4);  // "2024-10"
String quarter = LocalDateTimeUtils.formatDateRange(time, time, 5);// "2024-Q4"
String year = LocalDateTimeUtils.formatDateRange(time, time, 6);   // "2024"
```

**项目实际使用场景**:
- **报表生成**: 生成报表的时间轴标签
- **图表展示**: 格式化图表的 X 轴时间标签

---

#### `toEpochSecond(LocalDateTime sourceDateTime)` - 转换为 Unix 时间戳（秒）
**作用**: 将 LocalDateTime 转换为 Unix 时间戳（秒数）

**参数**:
- `sourceDateTime`: 待转换的时间

**返回值**: Unix 时间戳（秒）

**使用示例**:
```java
// 示例：将时间转换为时间戳
LocalDateTime time = LocalDateTime.now();
Long timestamp = LocalDateTimeUtils.toEpochSecond(time);

// 用于第三方接口调用
Map<String, Object> params = new HashMap<>();
params.put("timestamp", timestamp);
```

**项目实际使用场景**:
- **第三方接口调用**: 某些第三方接口需要 Unix 时间戳
- **签名计算**: 生成接口签名时需要时间戳

---

## 四、实战场景总结

### 场景1：BPM 流程任务时间查询
```java
// 前端传入 LocalDateTime，转换为 Date 给 Flowable 使用
LocalDateTime[] createTime = reqVO.getCreateTime();
if (createTime != null) {
    taskQuery.taskCreatedAfter(DateUtils.of(createTime[0]))
             .taskCreatedBefore(DateUtils.of(createTime[1]));
}
```

### 场景2：会员签到判断
```java
// 判断用户今天是否已签到
MemberSignInRecordDO todayRecord = signInMapper.selectByUserIdAndDay(userId, LocalDate.now());
if (todayRecord != null && DateUtils.isToday(todayRecord.getCreateTime())) {
    throw new BusinessException("今天已经签到过了");
}

// 判断是否连续签到
if (DateUtils.isYesterday(lastRecord.getCreateTime())) {
    // 连续签到，天数+1
    user.setContinuousDays(user.getContinuousDays() + 1);
} else {
    // 断签，重置为1
    user.setContinuousDays(1);
}
```

### 场景3：活动有效期判断
```java
// 判断活动是否在进行中
if (!LocalDateTimeUtils.isBetween(activity.getStartTime(), activity.getEndTime())) {
    throw new BusinessException("活动未开始或已结束");
}

// 判断优惠券是否过期
if (LocalDateTimeUtils.beforeNow(coupon.getValidEndTime())) {
    throw new BusinessException("优惠券已过期");
}
```

### 场景4：月度统计报表
```java
// 获取本月统计数据
LocalDateTime monthStart = LocalDateTimeUtils.beginOfMonth(LocalDateTime.now());
LocalDateTime monthEnd = LocalDateTimeUtils.endOfMonth(LocalDateTime.now());

// 查询本月订单
List<Order> monthOrders = orderMapper.selectBetween(monthStart, monthEnd);

// 计算本月销售额
BigDecimal monthRevenue = orderMapper.sumAmountBetween(monthStart, monthEnd);
```

### 场景5：时间段统计趋势
```java
// 生成最近30天的统计数据
LocalDateTime endTime = LocalDateTime.now();
LocalDateTime startTime = endTime.minusDays(30);

List<LocalDateTime[]> dayRanges = LocalDateTimeUtils.getDateRangeList(startTime, endTime, 2);
List<StatisticsVO> result = new ArrayList<>();

for (LocalDateTime[] range : dayRanges) {
    // 统计每天的数据
    Long orderCount = orderMapper.countBetween(range[0], range[1]);
    BigDecimal orderAmount = orderMapper.sumAmountBetween(range[0], range[1]);

    StatisticsVO vo = new StatisticsVO();
    vo.setDate(LocalDateTimeUtils.formatDateRange(range[0], range[1], 2));
    vo.setOrderCount(orderCount);
    vo.setOrderAmount(orderAmount);
    result.add(vo);
}
```

### 场景6：营业时间判断
```java
// 判断当前是否在营业时间
if (!LocalDateTimeUtils.isBetween("09:00:00", "22:00:00")) {
    throw new BusinessException("非营业时间，请在 9:00-22:00 之间下单");
}

// 判断预约时间是否冲突
boolean isConflict = LocalDateTimeUtils.isOverlap(
    appointment1.getStartTime(), appointment1.getEndTime(),
    appointment2.getStartTime(), appointment2.getEndTime()
);
if (isConflict) {
    throw new BusinessException("预约时间冲突");
}
```

---

## 五、注意事项

### 5.1 Date 与 LocalDateTime 的选择
1. **新代码优先使用 LocalDateTime**: 更现代、API 更友好、线程安全
2. **与第三方库集成时使用 Date**: Flowable、部分 MyBatis 场景
3. **使用 DateUtils.of() 进行转换**: 统一的转换方法，避免空指针

### 5.2 时间范围判断注意事项
1. **开始时间使用 00:00:00**: `beginOfMonth()` 会自动设置为当天开始
2. **结束时间使用 23:59:59.999**: `endOfMonth()` 会自动设置为当天结束
3. **时间范围包含边界**: `isBetween()` 是闭区间判断，包含起止时间

### 5.3 时间间隔枚举值
- 1: 小时（HOUR）
- 2: 天（DAY）
- 3: 周（WEEK）
- 4: 月（MONTH）
- 5: 季度（QUARTER）
- 6: 年（YEAR）

### 5.4 时区问题
- 所有时间默认使用系统时区（`ZoneId.systemDefault()`）
- 项目默认时区为 `GMT+8`（东八区）
- 进行国际化项目时需要注意时区转换

### 5.5 性能考虑
1. **批量统计时避免循环查询**: 使用 `getDateRangeList()` 生成范围后批量查询
2. **缓存常用时间**: 如今天的开始时间可以缓存复用
3. **数据库索引**: 时间字段查询要确保有索引

---

## 六、常见问题

### Q1: 为什么要同时提供 Date 和 LocalDateTime 两套工具？
A: 因为项目中同时存在新老代码，第三方库（如 Flowable）仍使用 Date，而新代码使用 LocalDateTime。两套工具方便相互转换。

### Q2: `isBetween()` 是开区间还是闭区间？
A: 闭区间，包含起止时间。即 `startTime <= time <= endTime`。

### Q3: `getDateRangeList()` 生成的时间范围最后一个元素会超过 endTime 吗？
A: 不会，代码中有兜底逻辑，最后一个时间范围的结束时间会被调整为 endTime。

### Q4: 如何判断两个时间段是否重叠？
A: 使用 `isOverlap()` 方法，它会自动判断两个时间段是否有交集。

### Q5: 为什么 `parse()` 方法要做两次解析？
A: 第一次尝试按标准格式解析（性能更好），失败后使用 Hutool 的智能解析（兼容性更好）。

---

## 七、运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Service、Controller、Mapper 等任何地方
- **依赖库**: Hutool (`cn.hutool.core.date`)、Java 8 Time API
- **设计模式**: 门面模式（封装复杂的时间操作，提供简单接口）
- **线程安全**: 所有方法都是无状态的，线程安全

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**维护者**: Ashore 团队  
