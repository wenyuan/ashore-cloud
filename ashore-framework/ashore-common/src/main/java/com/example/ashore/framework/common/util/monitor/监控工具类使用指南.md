# 监控工具类使用指南

## 一、包概览

`monitor` 包提供了应用监控和链路追踪的工具类，主要包含：

- **TracerUtils**: 链路追踪工具类（基于 SkyWalking）

该类用于获取分布式系统中的链路追踪编号，便于追踪请求在各个服务间的调用链���。

---

## 二、TracerUtils 类详解

### 2.1 类的整体介绍

`TracerUtils` 是链路追踪工具类，主要解决以下问题：

1. **分布式追踪**: 在微服务架构中追踪请求的完整调用链路
2. **日志关联**: 将同一请求的日志通过 TraceId 关联起来
3. **问题定位**: 快速定位分布式系统中的问题节点
4. **性能分析**: 分析请求在各个服务中的耗时

**为什么要二次封装？**
- 统一获取 TraceId 的方式，避免直接依赖 SkyWalking API
- 提供统一的工具类接口，便于后续切换其他链路追踪组件（如 Zipkin、Jaeger）
- 简化使用，开发人员无需关心底层实现

**基于 SkyWalking**:
项目使用 Apache SkyWalking 作为链路追踪组件，TracerUtils 是对 SkyWalking API 的简单封装。

### 2.2 核心方法详解

#### `getTraceId()` - 获取链路追踪编号
**作用**: 获取当前请求的链路追踪编号（TraceId）

**参数**: 无

**返回值**:
- String - 链路追踪编号
- "" (空字符串) - 如果不存在 TraceId

**TraceId 格式**:
SkyWalking 的 TraceId 格式为：`segment-id.span-id.parent-span-id`
例如：`1234567890.123.456`

**使用示例**:
```java
// 示例1：获取 TraceId
String traceId = TracerUtils.getTraceId();
// 结果：可能是 "TID.1234567890.123.456" 或 ""（不存在时）

// 示例2：记录日志时添加 TraceId
String traceId = TracerUtils.getTraceId();
log.info("处理订单，TraceId: {}, orderId: {}", traceId, orderId);

// 示例3：返回给前端
String traceId = TracerUtils.getTraceId();
response.setHeader("X-Trace-Id", traceId);

// 示例4：判断是否存在 TraceId
String traceId = TracerUtils.getTraceId();
if (StrUtil.isNotEmpty(traceId)) {
    // 存在链路追踪
    log.info("TraceId: {}", traceId);
} else {
    // 不存在链路追踪（可能未启用 SkyWalking）
    log.info("TraceId not available");
}
```

**项目实际使用场景**:

#### 场景1：HTTP 响应头添加 TraceId
在 `GlobalResponseBodyHandler` 中，将 TraceId 添加到响应头，便于前端追踪请求：
```java
// ashore-framework/ashore-spring-boot-starter-web/src/main/java/com/example/ashore/framework/web/core/handler/GlobalResponseBodyHandler.java
@Override
public ServerHttpResponse beforeBodyWrite(Object body, ...) {
    ServerHttpResponse response = ...;

    // 添加 TraceId 到响应头
    String traceId = TracerUtils.getTraceId();
    if (StrUtil.isNotEmpty(traceId)) {
        response.getHeaders().add("X-Trace-Id", traceId);
    }

    return response;
}
```

#### 场景2：异常日志记录 TraceId
在 `GlobalExceptionHandler` 中，记录异常时带上 TraceId，便于追踪问题：
```java
// ashore-framework/ashore-spring-boot-starter-web/src/main/java/com/example/ashore/framework/web/core/handler/GlobalExceptionHandler.java
@ExceptionHandler(value = Exception.class)
public CommonResult<?> handleException(HttpServletRequest req, Exception e) {
    // 记录异常日志，带上 TraceId
    String traceId = TracerUtils.getTraceId();
    log.error("请求异常，TraceId: {}, url: {}, method: {}",
        traceId, req.getRequestURI(), req.getMethod(), e);

    // 返回错误响应
    return CommonResult.error(500, "系统异常，TraceId: " + traceId);
}
```

#### 场景3：登录日志记录 TraceId
在 `AuthServiceImpl` 中，记录登录日志时带上 TraceId：
```java
// ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/service/auth/AuthServiceImpl.java
@Override
public LoginUser login(String username, String password) {
    // 登录逻辑
    LoginUser loginUser = doLogin(username, password);

    // 记录登录日志
    LoginLogCreateReqDTO loginLog = new LoginLogCreateReqDTO();
    loginLog.setUsername(username);
    loginLog.setTraceId(TracerUtils.getTraceId());  // 记录 TraceId
    loginLog.setUserAgent(ServletUtils.getUserAgent());
    loginLog.setClientIp(ServletUtils.getClientIP());
    loginLogService.createLoginLog(loginLog);

    return loginUser;
}
```

---

## 三、链路追踪原理

### 3.1 什么是链路追踪？

链路追踪（Distributed Tracing）是一种用于分析和监控微服务应用的技术，它可以追踪一个请求在分布式系统中的完整调用链路。

**核心概念**:
- **Trace**: 一次完整的请求链路，由多个 Span 组成
- **Span**: 链路中的一个节点（一次服务调用）
- **TraceId**: 全局唯一的追踪编号，标识一次完整的请求

### 3.2 SkyWalking 链路追踪流程

```
用户请求 -> 网关 -> 用户服务 -> 订单服务 -> 支付服务
    ↓         ↓         ↓           ↓           ↓
  TraceId   TraceId   TraceId     TraceId     TraceId
 (生成)    (传递)    (传递)      (传递)      (传递)
```

1. **请求入口**: 第一个服务（通常是网关）生成 TraceId
2. **TraceId 传递**: TraceId 通过 HTTP Header 或 RPC 框架传递给下游服务
3. **链路采集**: 每个服务记录自己的 Span，并上报给 SkyWalking
4. **链路分析**: SkyWalking 将所有 Span 组装成完整的 Trace，展示调用链路

### 3.3 TraceId 的传播

SkyWalking 通过 **Java Agent** 自动完成 TraceId 的传播：

```java
// HTTP 请求
// 自动在请求头中添加：sw8: traceId...
HttpClient.get("http://order-service/create", headers);

// RPC 调用（Dubbo/Feign）
// 自动在 RPC 上下文中传递 TraceId
orderService.createOrder(orderId);

// 消息队列（RabbitMQ/Kafka）
// 自动在消息头中添加 TraceId
rabbitTemplate.send("order-queue", message);
```

开发人员无需手动传递 TraceId，SkyWalking Agent 会自动处理。

---

## 四、实战场景总结

### 场景1：HTTP 响应头添加 TraceId（便于前端追踪）
```java
// 全局响应拦截器
@RestControllerAdvice
public class GlobalResponseBodyHandler implements ResponseBodyAdvice<Object> {

    @Override
    public Object beforeBodyWrite(Object body, ...) {
        // 获取 TraceId
        String traceId = TracerUtils.getTraceId();

        // 添加到响应头
        if (StrUtil.isNotEmpty(traceId)) {
            HttpServletResponse response = ((ServletRequestAttributes)
                RequestContextHolder.getRequestAttributes()).getResponse();
            response.setHeader("X-Trace-Id", traceId);
        }

        return body;
    }
}

// 前端接收 TraceId
fetch('/api/user/create', {
    method: 'POST',
    body: JSON.stringify(userData)
})
.then(response => {
    // 获取 TraceId
    const traceId = response.headers.get('X-Trace-Id');
    console.log('TraceId:', traceId);

    // 如果请求失败，可以将 TraceId 提供给客服或开发人员
    if (!response.ok) {
        alert('请求失败，请提供 TraceId: ' + traceId);
    }
});
```

### 场景2：异常日志记录 TraceId（便于问题定位）
```java
// 全局异常处理器
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(value = Exception.class)
    public CommonResult<?> handleException(HttpServletRequest req, Exception e) {
        // 获取 TraceId
        String traceId = TracerUtils.getTraceId();

        // 记录异常日志（带 TraceId）
        log.error("系统异常，TraceId: {}, url: {}, method: {}, params: {}",
            traceId,
            req.getRequestURI(),
            req.getMethod(),
            ServletUtils.getParamMap(req),
            e);

        // 返回错误（带 TraceId）
        return CommonResult.error(500, "系统异常，请联系管理员（TraceId: " + traceId + ")");
    }
}

// 用户看到错误提示：
// "系统异常，请联系管理员（TraceId: TID.1234567890.123.456）"

// 开发人员根据 TraceId 在 SkyWalking 中查询完整调用链路
// 1. 打开 SkyWalking UI
// 2. 输入 TraceId: TID.1234567890.123.456
// 3. 查看完整的调用链路和每个节点的耗时
// 4. 定位问题节点
```

### 场景3：业务日志记录 TraceId（便于日志关联）
```java
// 订单服务
@Service
public class OrderServiceImpl implements OrderService {

    @Override
    public void createOrder(OrderCreateReqVO reqVO) {
        String traceId = TracerUtils.getTraceId();

        // 1. 创建订单
        log.info("创建订单，TraceId: {}, userId: {}, amount: {}",
            traceId, reqVO.getUserId(), reqVO.getAmount());
        OrderDO order = createOrderDO(reqVO);
        orderMapper.insert(order);

        // 2. 扣减库存（调用商品服务）
        log.info("扣减库存，TraceId: {}, orderId: {}, productId: {}",
            traceId, order.getId(), reqVO.getProductId());
        productService.deductStock(reqVO.getProductId(), reqVO.getQuantity());

        // 3. 创建支付单（调用支付服务）
        log.info("创建支付单，TraceId: {}, orderId: {}, amount: {}",
            traceId, order.getId(), order.getAmount());
        payService.createPayOrder(order.getId(), order.getAmount());

        log.info("订单创建成功，TraceId: {}, orderId: {}", traceId, order.getId());
    }
}

// 日志输出：
// 2024-10-19 14:30:00 INFO  创建订单，TraceId: TID.123.456, userId: 1, amount: 99.99
// 2024-10-19 14:30:01 INFO  扣减库存，TraceId: TID.123.456, orderId: 10001, productId: 5001
// 2024-10-19 14:30:02 INFO  创建支付单，TraceId: TID.123.456, orderId: 10001, amount: 99.99
// 2024-10-19 14:30:03 INFO  订单创建成功，TraceId: TID.123.456, orderId: 10001

// 通过 TraceId 可以在日志系统中查询这一次请求的所有日志
```

### 场景4：登录日志记录 TraceId
```java
// 登录服务
@Service
public class AuthServiceImpl implements AuthService {

    @Override
    public LoginUser login(LoginReqVO reqVO) {
        String traceId = TracerUtils.getTraceId();

        try {
            // 1. 验证用户名密码
            log.info("用户登录，TraceId: {}, username: {}", traceId, reqVO.getUsername());
            LoginUser loginUser = authenticate(reqVO);

            // 2. 生成令牌
            String accessToken = tokenService.createAccessToken(loginUser);

            // 3. 记录登录日志
            LoginLogCreateReqDTO loginLog = new LoginLogCreateReqDTO();
            loginLog.setUsername(reqVO.getUsername());
            loginLog.setTraceId(traceId);
            loginLog.setResult(LoginLogResultEnum.SUCCESS.getCode());
            loginLog.setUserAgent(ServletUtils.getUserAgent());
            loginLog.setClientIp(ServletUtils.getClientIP());
            loginLogService.createLoginLog(loginLog);

            log.info("登录成功，TraceId: {}, username: {}, userId: {}",
                traceId, reqVO.getUsername(), loginUser.getId());

            return loginUser;
        } catch (Exception e) {
            // 4. 记录登录失败日志
            log.error("登录失败，TraceId: {}, username: {}", traceId, reqVO.getUsername(), e);

            LoginLogCreateReqDTO loginLog = new LoginLogCreateReqDTO();
            loginLog.setUsername(reqVO.getUsername());
            loginLog.setTraceId(traceId);
            loginLog.setResult(LoginLogResultEnum.FAILURE.getCode());
            loginLogService.createLoginLog(loginLog);

            throw e;
        }
    }
}
```

### 场景5：API 访问日志记录 TraceId
```java
// API 访问日志拦截器
@Component
public class ApiAccessLogInterceptor implements HandlerInterceptor {

    @Override
    public void afterCompletion(HttpServletRequest request, ...) {
        // 记录 API 访问日志
        ApiAccessLogCreateReqDTO accessLog = new ApiAccessLogCreateReqDTO();
        accessLog.setTraceId(TracerUtils.getTraceId());
        accessLog.setUrl(request.getRequestURI());
        accessLog.setMethod(request.getMethod());
        accessLog.setUserAgent(ServletUtils.getUserAgent(request));
        accessLog.setClientIp(ServletUtils.getClientIP(request));
        accessLog.setStartTime(startTime);
        accessLog.setDuration((int) (System.currentTimeMillis() - startTime));

        apiAccessLogService.createApiAccessLog(accessLog);
    }
}

// 在 SkyWalking 中可以看到：
// 1. 请求的完整调用链路
// 2. 每个服务的响应时间
// 3. 慢查询 SQL（如果有）
// 4. 异常堆栈（如果有）
```

### 场景6：分布式事务追踪
```java
// 订单服务（主事务）
@Service
public class OrderServiceImpl implements OrderService {

    @GlobalTransactional  // Seata 分布式事务
    @Override
    public void createOrder(OrderCreateReqVO reqVO) {
        String traceId = TracerUtils.getTraceId();
        log.info("开始创建订单，TraceId: {}", traceId);

        // 1. 创建订单
        OrderDO order = createOrderDO(reqVO);
        orderMapper.insert(order);

        // 2. 扣减库存（远程调用商品服务）
        productService.deductStock(reqVO.getProductId(), reqVO.getQuantity());

        // 3. 扣减余额（远程调用账户服务）
        accountService.deductBalance(reqVO.getUserId(), order.getAmount());

        log.info("订单创建完成，TraceId: {}, orderId: {}", traceId, order.getId());
    }
}

// 在 SkyWalking 中可以看到：
// Trace: TID.123.456
//   ├─ Span1: OrderService.createOrder      [200ms]
//   │   ├─ Span2: orderMapper.insert        [50ms]
//   │   ├─ Span3: ProductService.deductStock [80ms] (RPC 调用)
//   │   │   └─ Span4: productMapper.update   [60ms]
//   │   └─ Span5: AccountService.deductBalance [70ms] (RPC 调用)
//   │       └─ Span6: accountMapper.update   [50ms]

// 如果某个环节失败，可以快速定位是哪个服务、哪个方法出了问题
```

---

## 五、注意事项

### 5.1 TraceId 的生命周期
1. **请求开始时生成**: 第一个服务（网关）生成 TraceId
2. **请求结束时销毁**: 请求结束后 TraceId 会被清除
3. **异步线程**: 异步线程中 TraceId 可能丢失，需要手动传递

### 5.2 TraceId 为空的情况
1. **SkyWalking 未启动**: 如果 SkyWalking Agent 未启动，TraceId 为空字符串
2. **非 HTTP 请求**: 某些场景（如定时任务）可能没有 TraceId
3. **异步线程**: 异步线程中可能获取不到 TraceId

### 5.3 性能影响
1. **轻量级**: `TracerUtils.getTraceId()` 只是读取 ThreadLocal，性能开销极小
2. **自动采样**: SkyWalking 默认采样率为 100%，可以调整以减少性能影响
3. **异步上报**: Span 数据异步上报，不影响业务性能

### 5.4 异步场景处理
```java
// 问题：异步线程中 TraceId 丢失
@Service
public class OrderService {
    @Async
    public void sendNotification(Long orderId) {
        String traceId = TracerUtils.getTraceId();
        log.info("发送通知，TraceId: {}", traceId);  // TraceId 为空！
    }
}

// 解决方案1：手动传递 TraceId
@Service
public class OrderService {
    public void createOrder(OrderCreateReqVO reqVO) {
        String traceId = TracerUtils.getTraceId();

        // 将 TraceId 传递给异步方法
        CompletableFuture.runAsync(() -> {
            sendNotification(reqVO.getOrderId(), traceId);
        });
    }

    private void sendNotification(Long orderId, String traceId) {
        log.info("发送通知，TraceId: {}", traceId);
    }
}

// 解决方案2：使用 SkyWalking 的 @TraceCrossThread 注解
@Service
public class OrderService {
    @Async
    @TraceCrossThread  // SkyWalking 注解，自动传递 TraceId
    public void sendNotification(Long orderId) {
        String traceId = TracerUtils.getTraceId();
        log.info("发送通知，TraceId: {}", traceId);  // TraceId 正常！
    }
}
```

### 5.5 与日志系统集成
```xml
<!-- logback-spring.xml -->
<configuration>
    <!-- 在日志中自动添加 TraceId -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- %X{tid} 是 SkyWalking 自动注入的 TraceId -->
            <pattern>%d{HH:mm:ss.SSS} [%thread] [%X{tid}] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
</configuration>
```

---

## 六、常见问题

### Q1: TraceId 为空字符串怎么办？
A: 可能原因：
1. SkyWalking Agent 未启动或配置错误
2. 当前场景不在链路追踪范围内（如定时任务）
3. 异步线程中 TraceId 丢失

### Q2: 如何在 SkyWalking UI 中查询 TraceId？
A:
1. 打开 SkyWalking UI（默认：`http://localhost:8080`）
2. 点击 "Trace" 菜单
3. 输入 TraceId 或使用条件过滤
4. 查看完整的调用链路图

### Q3: TraceId 会影响性能吗？
A: 影响极小：
- `getTraceId()` 只是读取 ThreadLocal，耗时几乎为 0
- SkyWalking Agent 异步上报数据，不阻塞业务线程
- 可以调整采样率减少性能影响

### Q4: 如何让前端也能追踪请求？
A: 在响应头中添加 TraceId：
```java
response.setHeader("X-Trace-Id", TracerUtils.getTraceId());
```

前端可以获取并在报错时提供给开发人员：
```javascript
const traceId = response.headers.get('X-Trace-Id');
console.error('请求失败，TraceId:', traceId);
```

### Q5: 如何在定时任务中使用 TraceId？
A: 定时任务通常没有 TraceId，可以手动生成：
```java
@Scheduled(cron = "0 0 1 * * ?")
public void dailyTask() {
    // 手动生成 TraceId（使用 UUID）
    String traceId = "TASK-" + IdUtil.simpleUUID();

    log.info("定时任务开始，TraceId: {}", traceId);
    // 业务逻辑
}
```

### Q6: 为什么要放在 common 模块下？
A: 因为每个模块都可能需要获取 TraceId，放在 common 模块下避免循环依赖。

---

## 七、最佳实践

### 实践1：日志中统一记录 TraceId
```java
// 所有重要日志都带上 TraceId
String traceId = TracerUtils.getTraceId();
log.info("操作成功，TraceId: {}, userId: {}, orderId: {}", traceId, userId, orderId);
```

### 实践2：异常信息中包含 TraceId
```java
// 异常返回给用户时，带上 TraceId
String traceId = TracerUtils.getTraceId();
throw new BusinessException("操作失败，请联系管理员（TraceId: " + traceId + ")");
```

### 实践3：响应头中返回 TraceId
```java
// 所有 HTTP 响应都添加 TraceId 响应头
response.setHeader("X-Trace-Id", TracerUtils.getTraceId());
```

### 实践4：关键业务节点记录 TraceId
```java
// 在业务流程的关键节点记录 TraceId，便于追踪
String traceId = TracerUtils.getTraceId();
log.info("订单支付成功，TraceId: {}, orderId: {}, amount: {}", traceId, orderId, amount);
```

---

## 八、运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Service、Controller、Handler、Interceptor 等需要 TraceId 的地方
- **依赖库**: Apache SkyWalking (`org.apache.skywalking.apm.toolkit.trace`)
- **底层原理**: SkyWalking Agent 通过字节码增强技术，在请求入口处生成 TraceId，并通过 ThreadLocal 传递
- **线程安全**: 基于 ThreadLocal，天然线程安全
- **设计模式**: 门面模式（封装 SkyWalking API，提供简单接口）

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**维护者**: Ashore 团队  
