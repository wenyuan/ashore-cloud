# 数字计算工具类使用指南

## 一、包概览

`number` 包提供了金额计算和数字处理的工具类，主要包含两个核心类：

- **MoneyUtils**: 金额计算工具类
- **NumberUtils**: 数字解析和计算工具类

这两个类覆盖了项目中所有的金额计算和数字处理场景，确保计算精度和业务正确性。

---

## 二、MoneyUtils 类详解

### 2.1 类的整体介绍

`MoneyUtils` 是金额计算工具类，主要解决以下问题：

1. **精度问题**: 避免浮点数计算精度丢失（0.1 + 0.2 ≠ 0.3）
2. **舍入问题**: 统一金额的舍入规则（四舍五入/向下取整）
3. **单位转换**: 分与元的转换
4. **百分比计算**: 计算折扣、手续费等百分比金额

**为什么要二次封装？**
- 统一金额计算规则，避免不同开发人员使用不同的计算方式
- 简化 BigDecimal 的复杂 API
- 确保金额计算的精度和正确性

**核心常量**:
```java
private static final int PRICE_SCALE = 2;           // 金额小数位数（2位）
public static final BigDecimal PERCENT_100 = BigDecimal.valueOf(100);  // 百分比100
```

### 2.2 核心方法详解

#### `calculateRatePrice(Integer price, Double rate)` - 计算百分比金额（四舍五入）
**作用**: 计算金额的百分比，使用四舍五入

**参数**:
- `price`: 金额（单位：分）
- `rate`: 百分比（例如 56.77% 则传入 56.77）

**返回值**: 百分比金额（单位：分）

**使用示例**:
```java
// 示例1：计算优惠金额
Integer originalPrice = 10000;  // 100元
Double discountRate = 20.0;     // 20% 折扣

Integer discountAmount = MoneyUtils.calculateRatePrice(originalPrice, discountRate);
// 结果：2000（20元）
// 计算过程：10000 * 20 / 100 = 2000

// 示例2：计算手续费
Integer orderAmount = 9999;     // 99.99元
Double feeRate = 2.5;           // 2.5% 手续费

Integer fee = MoneyUtils.calculateRatePrice(orderAmount, feeRate);
// 结果：250（2.5元）
// 计算过程：9999 * 2.5 / 100 = 249.975 ≈ 250（四舍五入）

// 示例3：计算税费
Integer salesAmount = 50000;    // 500元
Double taxRate = 6.0;           // 6% 税率

Integer tax = MoneyUtils.calculateRatePrice(salesAmount, taxRate);
// 结果：3000（30元）
```

**项目实际使用场景**:
- **支付渠道费用**: 计算支付渠道的手续费
  ```java
  // ashore-module-pay/ashore-module-pay-biz/src/main/java/com/example/ashore/module/pay/service/order/PayOrderServiceImpl.java
  // 计算渠道费用
  Integer channelFeeRate = payChannel.getFeeRate();  // 例如：2.5（表示2.5%）
  Integer channelFee = MoneyUtils.calculateRatePrice(orderAmount, channelFeeRate.doubleValue());
  payOrder.setChannelFeeAmount(channelFee);
  ```

---

#### `calculateRatePriceFloor(Integer price, Double rate)` - 计算百分比金额（向下取整）
**作用**: 计算金额的百分比，使用向下取整

**参数**:
- `price`: 金额（单位：分）
- `rate`: 百分比

**返回值**: 百分比金额（单位：分）

**使用示例**:
```java
// 示例1：计算积分（向下取整，不能给多）
Integer orderAmount = 9999;     // 99.99元
Double pointsRate = 1.0;        // 1% 积分

Integer points = MoneyUtils.calculateRatePriceFloor(orderAmount, pointsRate);
// 结果：99（0.99元）
// 计算过程：9999 * 1 / 100 = 99.99 → 99（向下取整）

// 示例2：计算返利（向下取整，避免多返）
Integer salesAmount = 12345;    // 123.45元
Double rebateRate = 5.0;        // 5% 返利

Integer rebate = MoneyUtils.calculateRatePriceFloor(salesAmount, rebateRate);
// 结果：617（6.17元）
// 计算过程：12345 * 5 / 100 = 617.25 → 617（向下取整）
```

**项目实际使用场景**:
- **订单积分赠送**: 计算订单赠送的积分（向下取整，避免多送）
  ```java
  // ashore-module-trade/ashore-module-trade-biz/src/main/java/com/example/ashore/module/trade/service/order/TradeOrderServiceImpl.java
  // 计算订单赠送积分
  Integer payAmount = order.getPayAmount();           // 订单支付金额
  Double pointsRate = rewardConfig.getPointsRate();   // 积分比例（例如：1.0 表示 1%）

  Integer points = MoneyUtils.calculateRatePriceFloor(payAmount, pointsRate);
  order.setGivePoints(points);
  ```

---

#### `fenToYuan(int fen)` - 分转元（BigDecimal）
**作用**: 将金额从分转换为元（BigDecimal 类型）

**参数**:
- `fen`: 金额（单位：分）

**返回值**: 金额（单位：元，BigDecimal 类型）

**使用示例**:
```java
// 示例：分转元
int fen = 9999;  // 99.99元（分）
BigDecimal yuan = MoneyUtils.fenToYuan(fen);
// 结果：99.99

// 用于计算
BigDecimal totalYuan = MoneyUtils.fenToYuan(10000);
BigDecimal discount = totalYuan.multiply(new BigDecimal("0.8"));  // 8折
```

---

#### `fenToYuanStr(int fen)` - 分转元（字符串）
**作用**: 将金额从分转换为元（字符串类型）

**参数**:
- `fen`: 金额（单位：分）

**返回值**: 金额（单位：元，字符串类型）

**使用示例**:
```java
// 示例1：展示金额
int fen = 9999;  // 99.99元
String yuan = MoneyUtils.fenToYuanStr(fen);
// 结果："99.99"

// 示例2：日志输出
log.info("订单金额：{} 元", MoneyUtils.fenToYuanStr(order.getAmount()));
// 输出：订单金额：99.99 元

// 示例3：特殊金额
String yuan1 = MoneyUtils.fenToYuanStr(1);      // "0.01"
String yuan2 = MoneyUtils.fenToYuanStr(10);     // "0.10"
String yuan3 = MoneyUtils.fenToYuanStr(100);    // "1.00"
```

**项目实际使用场景**:
- **订单调价日志**: 记录调价金额（元）
  ```java
  // ashore-module-trade/ashore-module-trade-biz/src/main/java/com/example/ashore/module/trade/service/order/TradeOrderUpdateServiceImpl.java
  // 记录订单调价日志
  Integer oldAmount = order.getAmount();
  Integer newAmount = reqVO.getAmount();
  Integer diff = newAmount - oldAmount;

  String logMessage = String.format("订单调价：原价 %s 元，现价 %s 元，差额 %s 元",
      MoneyUtils.fenToYuanStr(oldAmount),
      MoneyUtils.fenToYuanStr(newAmount),
      MoneyUtils.fenToYuanStr(Math.abs(diff)));

  operateLogService.createOperateLog(logMessage);
  ```

---

#### `priceMultiply(BigDecimal price, BigDecimal count)` - 金额相乘
**作用**: 金额乘以数量，自动四舍五入保留2位小数

**参数**:
- `price`: 单价
- `count`: 数量

**返回值**: 总金额（保留2位小数）

**使用示例**:
```java
// 示例1：计算商品总价
BigDecimal unitPrice = new BigDecimal("99.99");  // 单价
BigDecimal quantity = new BigDecimal("3");        // 数量

BigDecimal totalPrice = MoneyUtils.priceMultiply(unitPrice, quantity);
// 结果：299.97（99.99 * 3）

// 示例2：处理精度问题
BigDecimal price = new BigDecimal("19.99");
BigDecimal count = new BigDecimal("1.5");

BigDecimal total = MoneyUtils.priceMultiply(price, count);
// 结果：29.99（19.99 * 1.5 = 29.985 → 29.99，四舍五入）

// 示例3：null 值处理
BigDecimal result = MoneyUtils.priceMultiply(null, new BigDecimal("10"));
// 结果：null（任意参数为 null 则返回 null）
```

**项目实际使用场景**:
- **ERP 销售订单**: 计算销售订单明细的总价
  ```java
  // ashore-module-erp/ashore-module-erp-biz/src/main/java/com/example/ashore/module/erp/service/sale/ErpSaleOrderServiceImpl.java
  // 计算订单明细总价
  for (ErpSaleOrderItemDO item : items) {
      BigDecimal unitPrice = item.getPrice();      // 单价
      BigDecimal quantity = item.getCount();        // 数量

      BigDecimal totalPrice = MoneyUtils.priceMultiply(unitPrice, quantity);
      item.setTotalPrice(totalPrice);
  }
  ```

---

#### `priceMultiplyPercent(BigDecimal price, BigDecimal percent)` - 金额乘百分比
**作用**: 金额乘以百分比，自动除以100并四舍五入保留2位小数

**参数**:
- `price`: 金额
- `percent`: 百分比（例如：80 表示 80%）

**返回值**: 计算结果（保留2位小数）

**使用示例**:
```java
// 示例1：计算折扣后金额
BigDecimal originalPrice = new BigDecimal("100.00");  // 原价
BigDecimal discount = new BigDecimal("80");           // 8折（80%）

BigDecimal finalPrice = MoneyUtils.priceMultiplyPercent(originalPrice, discount);
// 结果：80.00（100 * 80 / 100）

// 示例2：计算手续费
BigDecimal amount = new BigDecimal("500.00");
BigDecimal feeRate = new BigDecimal("2.5");           // 2.5% 手续费

BigDecimal fee = MoneyUtils.priceMultiplyPercent(amount, feeRate);
// 结果：12.50（500 * 2.5 / 100）

// 示例3：null 值处理
BigDecimal result = MoneyUtils.priceMultiplyPercent(null, new BigDecimal("80"));
// 结果：null
```

**项目实际使用场景**:
- **ERP 销售订单折扣**: 计算折扣后金额
  ```java
  // ashore-module-erp/ashore-module-erp-biz/src/main/java/com/example/ashore/module/erp/service/sale/ErpSaleOrderServiceImpl.java
  // 计算折扣后金额
  BigDecimal totalPrice = item.getTotalPrice();     // 总价
  BigDecimal discountPercent = item.getDiscount();  // 折扣（例如：80 表示 8折）

  BigDecimal discountedPrice = MoneyUtils.priceMultiplyPercent(totalPrice, discountPercent);
  item.setDiscountedPrice(discountedPrice);
  ```

---

## 三、NumberUtils 类详解

### 3.1 类的整体介绍

`NumberUtils` 是数字工具类，主要解决以下问题：

1. **字符串转数字**: 安全地将字符串转换为数字（避免空指针）
2. **数字验证**: 判断字符串是否全为数字
3. **地理计算**: 计算两点间的距离
4. **精确计算**: 精确的乘法运算（支持 null 处理）

**为什么要二次封装？**
- Hutool 的 `NumberUtil` 不支持返回 null（空字符串会抛异常）
- 补充 Hutool 缺失的功能（如经纬度距离计算）
- 提供更符合业务需求的 API

### 3.2 核心方法详解

#### `parseLong(String str)` - 字符串转 Long
**作用**: 安全地将字符串转换为 Long，空字符串返回 null

**参数**:
- `str`: 字符串

**返回值**: Long 对象，如果字符串为空则返回 null

**使用示例**:
```java
// 示例1：正常转换
Long id = NumberUtils.parseLong("123456");
// 结果：123456L

// 示例2：空字符串处理
Long id = NumberUtils.parseLong("");
// 结果：null（不抛异常）

// 示例3：null 处理
Long id = NumberUtils.parseLong(null);
// 结果：null

// 示例4：实际应用
String userIdStr = request.getParameter("userId");
Long userId = NumberUtils.parseLong(userIdStr);
if (userId != null) {
    User user = userService.getUserById(userId);
}
```

**项目实际使用场景**:
- **BPM 表单 ID 解析**: 解析表单字段中的 ID
  ```java
  // ashore-module-bpm/ashore-module-bpm-biz/src/main/java/com/example/ashore/module/bpm/service/task/BpmTaskServiceImpl.java
  // 解析表单字段值（可能是 Long 型 ID）
  String fieldValue = formData.get("userId");
  Long userId = NumberUtils.parseLong(fieldValue);
  if (userId != null) {
      User user = userService.getUser(userId);
  }
  ```

- **CRM 统计**: 解析用户 ID
  ```java
  // ashore-module-crm/ashore-module-crm-biz/src/main/java/com/example/ashore/module/crm/service/statistics/CrmStatisticsServiceImpl.java
  String userIdStr = reqVO.getUserId();
  Long userId = NumberUtils.parseLong(userIdStr);
  ```

---

#### `parseInt(String str)` - 字符串转 Integer
**作用**: 安全地将字符串转换为 Integer，空字符串返回 null

**参数**:
- `str`: 字符串

**返回值**: Integer 对象，如果字符串为空则返回 null

**使用示例**:
```java
// 示例：URL 参数解析
String pageNoStr = request.getParameter("pageNo");
Integer pageNo = NumberUtils.parseInt(pageNoStr);
if (pageNo == null) {
    pageNo = 1;  // 默认第一页
}
```

---

#### `isAllNumber(List<String> values)` - 判断是否全为数字
**作用**: 判断字符串列表中的所有元素是否都是数字

**参数**:
- `values`: 字符串列表

**返回值**: true-全为数字，false-有非数字元素或列表为空

**使用示例**:
```java
// 示例1：验证输入
List<String> ids = Arrays.asList("123", "456", "789");
boolean allNumber = NumberUtils.isAllNumber(ids);
// 结果：true

// 示例2：包含非数字
List<String> mixed = Arrays.asList("123", "abc", "789");
boolean allNumber = NumberUtils.isAllNumber(mixed);
// 结果：false

// 示例3：实际应用
List<String> userIds = reqVO.getUserIds();
if (!NumberUtils.isAllNumber(userIds)) {
    throw new BusinessException("用户ID必须为数字");
}

// 转换为 Long 列表
List<Long> ids = userIds.stream()
    .map(Long::valueOf)
    .collect(Collectors.toList());
```

---

#### `getDistance(double lat1, double lng1, double lat2, double lng2)` - 计算地球上两点间的距离
**作用**: 通过经纬度计算地球上两点之间的距离（使用 Haversine 公式）

**参数**:
- `lat1`: 经度1
- `lng1`: 纬度1
- `lat2`: 经度2
- `lng2`: 纬度2

**返回值**: 距离（单位：千米）

**使用示例**:
```java
// 示例1：计算北京到上海的距离
double distance = NumberUtils.getDistance(
    39.9042,  // 北京纬度
    116.4074, // 北京经度
    31.2304,  // 上海纬度
    121.4737  // 上海经度
);
// 结果：约 1067.0（千米）

// 示例2：判断是否在配送范围内
double userLat = 39.9;
double userLng = 116.4;
double shopLat = 39.95;
double shopLng = 116.45;

double distance = NumberUtils.getDistance(userLat, userLng, shopLat, shopLng);
if (distance > 5.0) {  // 配送范围5公里
    throw new BusinessException("超出配送范围");
}

// 示例3：查找附近的店铺
List<Shop> shops = shopMapper.selectAll();
List<Shop> nearbyShops = shops.stream()
    .filter(shop -> {
        double distance = NumberUtils.getDistance(
            userLat, userLng,
            shop.getLatitude(), shop.getLongitude()
        );
        return distance <= 10.0;  // 10公里内
    })
    .collect(Collectors.toList());
```

**计算原理**:
使用 Haversine 公式计算球面距离：
```
a = sin²(Δlat/2) + cos(lat1) * cos(lat2) * sin²(Δlng/2)
c = 2 * atan2(√a, √(1−a))
d = R * c

其中 R = 6378.137 千米（地球半径）
```

---

#### `mul(BigDecimal... values)` - 精确乘法
**作用**: 多个数字相乘，如果任意一个为 null 则返回 null

**参数**:
- `values`: 多个被乘数

**返回值**: 乘积，如果任意参数为 null 则返回 null

**使用示例**:
```java
// 示例1：正常相乘
BigDecimal result = NumberUtils.mul(
    new BigDecimal("10"),
    new BigDecimal("2.5"),
    new BigDecimal("3")
);
// 结果：75.0（10 * 2.5 * 3）

// 示例2：包含 null
BigDecimal result = NumberUtils.mul(
    new BigDecimal("10"),
    null,
    new BigDecimal("3")
);
// 结果：null

// 示例3：与 Hutool 的区别
// Hutool 的 NumberUtil.mul()：遇到 null 会跳过
BigDecimal hutoolResult = NumberUtil.mul(new BigDecimal("10"), null, new BigDecimal("3"));
// 结果：30.0（忽略 null）

// NumberUtils.mul()：遇到 null 返回 null
BigDecimal ourResult = NumberUtils.mul(new BigDecimal("10"), null, new BigDecimal("3"));
// 结果：null
```

**使用场景**:
- **价格计算**: 单价 × 数量 × 折扣，任意一个为 null 则无法计算
- **数据完整性校验**: 如果某个参数为 null，说明数据不完整

---

## 四、实战场景总结

### 场景1：订单积分计算（向下取整）
```java
// 用户下单后赠送积分，积分比例为订单金额的1%
// 使用向下取整，避免多送积分

public void calculateOrderPoints(TradeOrderDO order) {
    // 1. 获取订单支付金额（分）
    Integer payAmount = order.getPayAmount();  // 例如：9999 分（99.99元）

    // 2. 获取积分比例
    Double pointsRate = 1.0;  // 1%

    // 3. 计算积分（向下取整）
    Integer points = MoneyUtils.calculateRatePriceFloor(payAmount, pointsRate);
    // 结果：99 积分（9999 * 1 / 100 = 99.99 → 99）

    // 4. 保存积分
    order.setGivePoints(points);

    log.info("订单积分计算完成，orderId: {}, payAmount: {}, points: {}",
        order.getId(), MoneyUtils.fenToYuanStr(payAmount), points);
}
```

### 场景2：支付渠道手续费计算（四舍五入）
```java
// 计算支付渠道的手续费
// 使用四舍五入，确保手续费计算准确

public void calculateChannelFee(PayOrderDO payOrder) {
    // 1. 获取订单金额（分）
    Integer orderAmount = payOrder.getAmount();  // 例如：10000 分（100元）

    // 2. 获取渠道费率
    PayChannelDO channel = payChannelService.getChannel(payOrder.getChannelId());
    Double feeRate = channel.getFeeRate();  // 例如：2.5（2.5%）

    // 3. 计算手续费（四舍五入）
    Integer channelFee = MoneyUtils.calculateRatePrice(orderAmount, feeRate);
    // 结果：250 分（10000 * 2.5 / 100 = 250）

    // 4. 保存手续费
    payOrder.setChannelFeeAmount(channelFee);

    log.info("渠道手续费计算完成，orderId: {}, amount: {} 元, feeRate: {}%, fee: {} 元",
        payOrder.getId(),
        MoneyUtils.fenToYuanStr(orderAmount),
        feeRate,
        MoneyUtils.fenToYuanStr(channelFee));
}
```

### 场景3：ERP 销售订单金额计算
```java
// ERP 销售订单明细的金额计算：单价 × 数量 × 折扣

public void calculateOrderItemAmount(ErpSaleOrderItemDO item) {
    // 1. 获取单价和数量
    BigDecimal unitPrice = item.getPrice();      // 例如：99.99
    BigDecimal quantity = item.getCount();       // 例如：3

    // 2. 计算小计（单价 × 数量）
    BigDecimal subtotal = MoneyUtils.priceMultiply(unitPrice, quantity);
    // 结果：299.97（99.99 * 3）

    // 3. 应用折扣（如果有）
    BigDecimal discountPercent = item.getDiscount();  // 例如：80（8折）
    BigDecimal finalAmount;
    if (discountPercent != null) {
        finalAmount = MoneyUtils.priceMultiplyPercent(subtotal, discountPercent);
        // 结果：239.98（299.97 * 80 / 100 = 239.976 → 239.98）
    } else {
        finalAmount = subtotal;
    }

    // 4. 保存金额
    item.setSubtotal(subtotal);
    item.setFinalAmount(finalAmount);

    log.info("订单明细金额计算完成，itemId: {}, 单价: {}, 数量: {}, 小计: {}, 折扣: {}%, 实付: {}",
        item.getId(), unitPrice, quantity, subtotal, discountPercent, finalAmount);
}
```

### 场景4：LBS 附近店铺查询
```java
// 查询用户附近10公里内的店铺

public List<ShopVO> getNearbyShops(Double userLat, Double userLng, Integer maxDistance) {
    // 1. 查询所有店铺
    List<ShopDO> allShops = shopMapper.selectList();

    // 2. 筛选距离范围内的店铺
    List<ShopVO> nearbyShops = allShops.stream()
        .map(shop -> {
            // 计算距离
            double distance = NumberUtils.getDistance(
                userLat, userLng,
                shop.getLatitude(), shop.getLongitude()
            );

            // 构建 VO
            ShopVO vo = BeanUtils.toBean(shop, ShopVO.class);
            vo.setDistance(distance);
            return vo;
        })
        .filter(vo -> vo.getDistance() <= maxDistance)  // 过滤距离
        .sorted(Comparator.comparing(ShopVO::getDistance))  // 按距离排序
        .collect(Collectors.toList());

    log.info("附近店铺查询完成，用户位置: ({}, {}), 范围: {}km, 结果数: {}",
        userLat, userLng, maxDistance, nearbyShops.size());

    return nearbyShops;
}
```

### 场景5：订单调价日志
```java
// 记录订单调价操作日志，展示元为单位的金额

public void updateOrderAmount(Long orderId, Integer newAmount) {
    // 1. 查询订单
    TradeOrderDO order = orderMapper.selectById(orderId);
    Integer oldAmount = order.getAmount();

    // 2. 计算差额
    Integer diff = newAmount - oldAmount;

    // 3. 更新金额
    order.setAmount(newAmount);
    orderMapper.updateById(order);

    // 4. 记录日志（使用 fenToYuanStr 展示金额）
    String logMessage = String.format(
        "订单调价：订单号 %s, 原价 %s 元, 现价 %s 元, %s %s 元",
        order.getOrderNo(),
        MoneyUtils.fenToYuanStr(oldAmount),
        MoneyUtils.fenToYuanStr(newAmount),
        diff > 0 ? "涨价" : "降价",
        MoneyUtils.fenToYuanStr(Math.abs(diff))
    );

    operateLogService.createLog(logMessage);

    // 日志输出示例：
    // "订单调价：订单号 202410190001, 原价 99.99 元, 现价 89.99 元, 降价 10.00 元"
}
```

### 场景6：批量 ID 验证
```java
// 批量删除用户时，验证 ID 是否全为数字

public void batchDeleteUsers(List<String> userIds) {
    // 1. 验证 ID 是否全为数字
    if (!NumberUtils.isAllNumber(userIds)) {
        throw new BusinessException("用户ID必须为数字");
    }

    // 2. 转换为 Long 列表
    List<Long> ids = userIds.stream()
        .map(Long::valueOf)
        .collect(Collectors.toList());

    // 3. 批量删除
    userMapper.deleteBatchIds(ids);

    log.info("批量删除用户成功，数量: {}", ids.size());
}
```

---

## 五、注意事项

### 5.1 金额单位统一
1. **数据库存储**: 统一使用**分**（Integer）
2. **计算过程**: 使用**分**（Integer）或 BigDecimal
3. **展示给用户**: 转换为**元**（String）

### 5.2 舍入规则选择
1. **四舍五入** (`calculateRatePrice`): 用于费用计算、税费等
2. **向下取整** (`calculateRatePriceFloor`): 用于积分、返利等（不能多给）

### 5.3 BigDecimal 精度
1. **PRICE_SCALE = 2**: 金额统一保留2位小数
2. **避免 double**: 不要使用 double 进行金额计算
3. **字符串构造**: 使用 `new BigDecimal("99.99")`，不要用 `new BigDecimal(99.99)`

### 5.4 null 值处理
1. **MoneyUtils**: 方法不处理 null，调用方需要判空
2. **NumberUtils.parseLong/parseInt**: 返回 null 而不是抛异常
3. **NumberUtils.mul**: 任意参数为 null 则返回 null

### 5.5 距离计算精度
1. **地球半径**: 使用 6378.137 千米
2. **精度**: 保留 4 位小数（米级精度）
3. **适用范围**: 适用于短距离（<1000km），长距离误差较大

---

## 六、常见问题

### Q1: 为什么金额要用分而不是元？
A:
1. **避免精度问题**: Integer 不会有精度丢失
2. **数据库友好**: Integer 类型查询和存储效率更高
3. **计算简单**: 避免小数计算的复杂性

### Q2: calculateRatePrice 和 calculateRatePriceFloor 如何选择？
A:
- **calculateRatePrice**（四舍五入）: 费用、税金等需要准确计算的场景
- **calculateRatePriceFloor**（向下取整）: 积分、返利等不能多给的场景

### Q3: priceMultiply 和直接用 BigDecimal.multiply 有什么区别？
A:
- `priceMultiply`: 自动四舍五入保留2位小数，处理 null
- `BigDecimal.multiply`: 需要手动设置精度和舍入模式

### Q4: 为什么 NumberUtils.mul 遇到 null 返回 null，而 Hutool 的会跳过？
A: 项目需要严格的数据完整性校验，如果某个参数为 null，说明数据不完整，应该返回 null 而不是忽略。

### Q5: getDistance 的单位是什么？
A: 单位是**千米（km）**，如果需要米，结果乘以 1000。

### Q6: 为什么不直接使用 Hutool 的 NumberUtil？
A: Hutool 的 `parseLong` 遇到空字符串会抛异常，项目需要返回 null 的版本。

---

## 七、最佳实践

### 实践1：金额计算统一使用工具类
```java
// 好的做法：使用 MoneyUtils
Integer fee = MoneyUtils.calculateRatePrice(amount, rate);
BigDecimal total = MoneyUtils.priceMultiply(price, count);

// 不好的做法：直接计算
Integer fee = (int) (amount * rate / 100);  // 可能精度丢失
BigDecimal total = price.multiply(count);   // 没有设置精度
```

### 实践2：字符串转数字使用 NumberUtils
```java
// 好的做法：使用 NumberUtils
String idStr = request.getParameter("userId");
Long userId = NumberUtils.parseLong(idStr);
if (userId != null) {
    // 处理
}

// 不好的做法：直接转换
Long userId = Long.valueOf(idStr);  // 空字符串会抛异常
```

### 实践3：金额展示使用 fenToYuanStr
```java
// 好的做法：使用 fenToYuanStr
log.info("订单金额：{} 元", MoneyUtils.fenToYuanStr(order.getAmount()));

// 不好的做法：手动转换
log.info("订单金额：{} 元", order.getAmount() / 100.0);  // 可能精度问题
```

---

## 八、运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Service、Controller 等需要金额计算和数字处理的地方
- **依赖库**:
  - Hutool (`cn.hutool.core.math`, `cn.hutool.core.util`)
  - Java Math (`java.math.BigDecimal`)
- **设计模式**: 门面模式（封装复杂的数学计算，提供简单接口）
- **线程安全**: 所有方法都是无状态的，线程安全

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**维护者**: Ashore 团队  
