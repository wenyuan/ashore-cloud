# 对象工具类使用指南

## 一、包概览

`object` 包提供了对象操作和转换的工具类，主要包含三个核心类：

- **BeanUtils**: Bean 对象转换工具
- **ObjectUtils**: 对象操作工具
- **PageUtils**: 分页工具

这三个类覆盖了项目中所有的对象转换、操作和分页处理场景。

---

## 二、BeanUtils 类详解

### 2.1 类的整体介绍

`BeanUtils` 是 Bean 对象转换工具类，主要解决以下问题：

1. **DO ↔ VO 转换**: 简化数据对象和视图对象之间的转换
2. **批量转换**: 支持 List 和 PageResult 的批量转换
3. **属性复制**: 简化对象属性复制
4. **回调支持**: 转换后可以通过回调进行二次处理

**为什么要二次封装？**
- Hutool 的 `BeanUtil` 功能完善，但项目需要统一的转换规范
- 支持 PageResult 的转换（Hutool 不支持）
- 支持转换后的回调处理
- 统一使用一个工具类，便于后续切换底层实现（如 MapStruct）

**底层实现**: 基于 Hutool 的 `BeanUtil`

### 2.2 核心方法详解

#### `toBean(Object source, Class<T> targetClass)` - 单对象转换
**作用**: 将一个对象转换为另一个类型的对象

**参数**:
- `source`: 源对象
- `targetClass`: 目标类型

**返回值**: 转换后的对象

**使用示例**:
```java
// 示例1：DO 转 VO
UserDO userDO = userMapper.selectById(userId);
UserVO userVO = BeanUtils.toBean(userDO, UserVO.class);

// 示例2：VO 转 DO
UserCreateReqVO reqVO = new UserCreateReqVO();
reqVO.setName("张三");
reqVO.setAge(18);

UserDO userDO = BeanUtils.toBean(reqVO, UserDO.class);
userMapper.insert(userDO);

// 示例3：DTO 转 DTO
UserDTO sourceDTO = getUserDTO();
UserDetailDTO targetDTO = BeanUtils.toBean(sourceDTO, UserDetailDTO.class);
```

**项目实际使用场景**:
- **Controller 层**: DO 转 VO 返回给前端
  ```java
  // ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/controller/admin/user/UserController.java
  @GetMapping("/get")
  public CommonResult<UserVO> getUser(@RequestParam("id") Long id) {
      UserDO user = userService.getUser(id);
      return success(BeanUtils.toBean(user, UserVO.class));
  }
  ```

- **Service 层**: VO 转 DO 保存到数据库
  ```java
  // ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/service/user/UserServiceImpl.java
  @Override
  public Long createUser(UserCreateReqVO reqVO) {
      UserDO user = BeanUtils.toBean(reqVO, UserDO.class);
      userMapper.insert(user);
      return user.getId();
  }
  ```

---

#### `toBean(Object source, Class<T> targetClass, Consumer<T> peek)` - 单对象转换（带回调）
**作用**: 将对象转换后，通过回调函数进行二次处理

**参数**:
- `source`: 源对象
- `targetClass`: 目标类型
- `peek`: 回调函数，用于二次处理转换后的对象

**返回值**: 转换并处理后的对象

**使用示例**:
```java
// 示例1：转换后设置额外字段
UserDO userDO = userMapper.selectById(userId);
UserVO userVO = BeanUtils.toBean(userDO, UserVO.class, vo -> {
    // 设置部门名称
    DeptDO dept = deptService.getDept(userDO.getDeptId());
    vo.setDeptName(dept.getName());

    // 设置角色列表
    List<RoleDO> roles = roleService.getRolesByUserId(userDO.getId());
    vo.setRoles(roles);
});

// 示例2：数据脱敏
UserDO userDO = userMapper.selectById(userId);
UserVO userVO = BeanUtils.toBean(userDO, UserVO.class, vo -> {
    // 手机号脱敏
    vo.setMobile(DesensitizedUtil.mobilePhone(vo.getMobile()));

    // 邮箱脱敏
    vo.setEmail(DesensitizedUtil.email(vo.getEmail()));
});

// 示例3：计算衍生字段
OrderDO orderDO = orderMapper.selectById(orderId);
OrderVO orderVO = BeanUtils.toBean(orderDO, OrderVO.class, vo -> {
    // 计算优惠金额
    vo.setDiscountAmount(orderDO.getTotalAmount() - orderDO.getPayAmount());

    // 设置订单状态文本
    vo.setStatusText(OrderStatusEnum.getByCode(orderDO.getStatus()).getName());
});
```

**项目实际使用场景**:
- **查询用户详情**: 转换后补充关联数据
  ```java
  @Override
  public UserDetailVO getUserDetail(Long id) {
      UserDO user = userMapper.selectById(id);
      return BeanUtils.toBean(user, UserDetailVO.class, vo -> {
          // 补充部门信息
          DeptDO dept = deptMapper.selectById(user.getDeptId());
          vo.setDeptName(dept.getName());

          // 补充角色信息
          List<RoleDO> roles = roleMapper.selectByUserId(id);
          vo.setRoleNames(CollectionUtils.convertList(roles, RoleDO::getName));

          // 补充岗位信息
          List<PostDO> posts = postMapper.selectByUserId(id);
          vo.setPostNames(CollectionUtils.convertList(posts, PostDO::getName));
      });
  }
  ```

---

#### `toBean(List<S> source, Class<T> targetType)` - List 批量转换
**作用**: 将 List 中的每个元素转换为目标类型

**参数**:
- `source`: 源 List
- `targetType`: 目标元素类型

**返回值**: 转换后的 List

**使用示例**:
```java
// 示例1：DO List 转 VO List
List<UserDO> userDOs = userMapper.selectList();
List<UserVO> userVOs = BeanUtils.toBean(userDOs, UserVO.class);

// 示例2：DTO List 转 DO List
List<ProductDTO> productDTOs = getProductDTOs();
List<ProductDO> productDOs = BeanUtils.toBean(productDTOs, ProductDO.class);

// 示例3：空集合处理
List<UserDO> emptyList = new ArrayList<>();
List<UserVO> result = BeanUtils.toBean(emptyList, UserVO.class);
// 结果：[] （空列表，不会抛异常）

// 示例4：null 处理
List<UserDO> nullList = null;
List<UserVO> result = BeanUtils.toBean(nullList, UserVO.class);
// 结果：null
```

**项目实际使用场景**:
- **查询用户列表**: 批量转换 DO 为 VO
  ```java
  // ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/controller/admin/user/UserController.java
  @GetMapping("/list")
  public CommonResult<List<UserVO>> getUserList() {
      List<UserDO> users = userService.getUserList();
      return success(BeanUtils.toBean(users, UserVO.class));
  }
  ```

---

#### `toBean(List<S> source, Class<T> targetType, Consumer<T> peek)` - List 批量转换（带回调）
**作用**: 批量转换 List，每个元素转换后都会执行回调

**参数**:
- `source`: 源 List
- `targetType`: 目标元素类型
- `peek`: 回调函数，对每个转换后的对象进行处理

**返回值**: 转换并处理后的 List

**使用示例**:
```java
// 示例1：批量补充关联数据
List<OrderDO> orderDOs = orderMapper.selectList();
List<OrderVO> orderVOs = BeanUtils.toBean(orderDOs, OrderVO.class, vo -> {
    // 补充用户信息
    UserDO user = userService.getUser(vo.getUserId());
    vo.setUserName(user.getName());

    // 补充商品信息
    ProductDO product = productService.getProduct(vo.getProductId());
    vo.setProductName(product.getName());
});

// 示例2：批量数据脱敏
List<UserDO> userDOs = userMapper.selectList();
List<UserVO> userVOs = BeanUtils.toBean(userDOs, UserVO.class, vo -> {
    vo.setMobile(DesensitizedUtil.mobilePhone(vo.getMobile()));
    vo.setEmail(DesensitizedUtil.email(vo.getEmail()));
});

// 示例3：批量计算衍生字段
List<OrderDO> orderDOs = orderMapper.selectList();
List<OrderVO> orderVOs = BeanUtils.toBean(orderDOs, OrderVO.class, vo -> {
    // 计算优惠金额
    vo.setDiscountAmount(vo.getTotalAmount() - vo.getPayAmount());

    // 设置状态文本
    vo.setStatusText(OrderStatusEnum.getByCode(vo.getStatus()).getName());
});
```

**项目实际使用场景**:
- **订单列表查询**: 批量补充用户名和商品名
  ```java
  @Override
  public List<OrderVO> getOrderList(OrderPageReqVO reqVO) {
      List<OrderDO> orders = orderMapper.selectList(reqVO);
      return BeanUtils.toBean(orders, OrderVO.class, vo -> {
          // 补充用户名
          UserDO user = userService.getUser(vo.getUserId());
          vo.setUserName(user.getName());

          // 补充商品名
          ProductDO product = productService.getProduct(vo.getProductId());
          vo.setProductName(product.getName());
      });
  }
  ```

---

#### `toBean(PageResult<S> source, Class<T> targetType)` - 分页对象转换
**作用**: 转换分页对象（`PageResult`）

**参数**:
- `source`: 源分页对象
- `targetType`: 目标元素类型

**返回值**: 转换后的分页对象

**使用示例**:
```java
// 示例：分页查询用户
PageResult<UserDO> userPage = userMapper.selectPage(reqVO);
PageResult<UserVO> voPage = BeanUtils.toBean(userPage, UserVO.class);

// 结果：
// voPage.getList() -> 转换后的 VO 列表
// voPage.getTotal() -> 总记录数（与原分页对象相同）
```

**项目实际使用场景**:
- **分页查询**: 返回分页 VO
  ```java
  // ashore-module-system/ashore-module-system-biz/src/main/java/com/example/ashore/module/system/controller/admin/user/UserController.java
  @GetMapping("/page")
  public CommonResult<PageResult<UserVO>> getUserPage(@Valid UserPageReqVO reqVO) {
      PageResult<UserDO> pageResult = userService.getUserPage(reqVO);
      return success(BeanUtils.toBean(pageResult, UserVO.class));
  }
  ```

---

#### `toBean(PageResult<S> source, Class<T> targetType, Consumer<T> peek)` - 分页对象转换（带回调）
**作用**: 转换分页对象，每个元素转换后都会执行回调

**参数**:
- `source`: 源分页对象
- `targetType`: 目标元素类型
- `peek`: 回调函数

**返回值**: 转换并处理后的分页对象

**使用示例**:
```java
// 示例：分页查询订单并补充关联数据
PageResult<OrderDO> orderPage = orderMapper.selectPage(reqVO);
PageResult<OrderVO> voPage = BeanUtils.toBean(orderPage, OrderVO.class, vo -> {
    // 补充用户名
    UserDO user = userService.getUser(vo.getUserId());
    vo.setUserName(user.getName());

    // 补充商品名
    ProductDO product = productService.getProduct(vo.getProductId());
    vo.setProductName(product.getName());
});
```

**项目实际使用场景**:
- **ERP 出库单分页**: 转换后补充仓库名称和操作人姓名
  ```java
  // ashore-module-erp/ashore-module-erp-biz/src/main/java/com/example/ashore/module/erp/service/stock/ErpStockOutServiceImpl.java
  @Override
  public PageResult<ErpStockOutVO> getStockOutPage(ErpStockOutPageReqVO reqVO) {
      PageResult<ErpStockOutDO> pageResult = stockOutMapper.selectPage(reqVO);
      return BeanUtils.toBean(pageResult, ErpStockOutVO.class, vo -> {
          // 补充仓库名称
          ErpWarehouseDO warehouse = warehouseService.getWarehouse(vo.getWarehouseId());
          vo.setWarehouseName(warehouse.getName());

          // 补充操作人姓名
          AdminUserDO user = adminUserService.getUser(vo.getCreator());
          vo.setCreatorName(user.getNickname());
      });
  }
  ```

---

#### `copyProperties(Object source, Object target)` - 属性复制
**作用**: 将源对象的属性复制到目标对象

**参数**:
- `source`: 源对象
- `target`: 目标对象

**返回值**: 无（直接修改 target 对象）

**使用示例**:
```java
// 示例1：更新用户信息
UserDO user = userMapper.selectById(userId);
UserUpdateReqVO reqVO = getUpdateReqVO();

// 复制属性
BeanUtils.copyProperties(reqVO, user);
userMapper.updateById(user);

// 示例2：部分属性更新
ProductDO product = productMapper.selectById(productId);
ProductUpdateReqVO reqVO = getUpdateReqVO();

// 只更新请求中有的字段
BeanUtils.copyProperties(reqVO, product);
product.setUpdateTime(LocalDateTime.now());
productMapper.updateById(product);

// 示例3：DTO 传递
UserDTO sourceDTO = getSourceDTO();
UserDTO targetDTO = new UserDTO();

BeanUtils.copyProperties(sourceDTO, targetDTO);
// targetDTO 包含 sourceDTO 的所有属性
```

**注意事项**:
1. 属性名和类型必须一致才会复制
2. null 值也会被复制（会覆盖目标对象的值）
3. 如果 source 或 target 为 null，方法不执行任何操作

---

## 三、ObjectUtils 类详解

### 3.1 类的整体介绍

`ObjectUtils` 是对象操作工具类，主要解决以下问题：

1. **对象克隆**: 克隆对象并忽略 ID
2. **取最大值**: 取两个对象中的较大值
3. **默认值**: 返回第一个非 null 的对象
4. **包含判断**: 判断对象是否在数组中
5. **非空判断**: 判断是否不是全部为空

**为什么要二次封装？**
- 补充 Hutool `ObjectUtil` 缺失的功能
- 提供更符合业务需求的方法

### 3.2 核心方法详解

#### `cloneIgnoreId(T object, Consumer<T> consumer)` - 克隆对象并忽略 ID
**作用**: 克隆对象，自动将 ID 设置为 null，并可以通过回调进行二次编辑

**参数**:
- `object`: 待克隆的对象
- `consumer`: 回调函数，对克隆后的对象进行二次编辑

**返回值**: 克隆后的对象

**使用示例**:
```java
// 示例1：复制商品
ProductDO originalProduct = productMapper.selectById(productId);
ProductDO newProduct = ObjectUtils.cloneIgnoreId(originalProduct, product -> {
    product.setName(product.getName() + "-副本");
    product.setStatus(ProductStatusEnum.DRAFT.getCode());
});
productMapper.insert(newProduct);

// 示例2：复制订单模板
OrderTemplateDO template = templateMapper.selectById(templateId);
OrderTemplateDO newTemplate = ObjectUtils.cloneIgnoreId(template, t -> {
    t.setName(t.getName() + "-复制");
    t.setCreateTime(LocalDateTime.now());
});
templateMapper.insert(newTemplate);

// 示例3：测试用例
@Test
public void testCreateUser() {
    UserDO mockUser = mockUserDO();
    UserDO testUser = ObjectUtils.cloneIgnoreId(mockUser, user -> {
        user.setName("测试用户");
        user.setMobile("13800138000");
    });

    // testUser 的 ID 为 null，其他属性与 mockUser 相同
    assertNull(testUser.getId());
    assertEquals("测试用户", testUser.getName());
}
```

**项目实际使用场景**:
- **测试用例**: 快速创建测试数据
  ```java
  // ashore-module-system/ashore-module-system-biz/src/test/java/com/example/ashore/module/system/service/user/UserServiceImplTest.java
  @Test
  public void testUpdateUser() {
      // 1. 准备数据
      UserDO user = randomPojo(UserDO.class);
      userMapper.insert(user);

      // 2. 克隆并修改
      UserDO updateObj = ObjectUtils.cloneIgnoreId(user, u -> {
          u.setName("新名字");
      });

      // 3. 执行更新
      userService.updateUser(updateObj);

      // 4. 验证
      UserDO dbUser = userMapper.selectById(user.getId());
      assertEquals("新名字", dbUser.getName());
  }
  ```

---

#### `max(T obj1, T obj2)` - 取较大值
**作用**: 返回两个 Comparable 对象中的较大值

**参数**:
- `obj1`: 对象1
- `obj2`: 对象2

**返回值**: 较大的对象，如果某个为 null 则返回另一个

**使用示例**:
```java
// 示例1：取较大的日期
LocalDateTime date1 = LocalDateTime.of(2024, 10, 1, 0, 0);
LocalDateTime date2 = LocalDateTime.of(2024, 10, 15, 0, 0);
LocalDateTime maxDate = ObjectUtils.max(date1, date2);
// 结果：2024-10-15 00:00

// 示例2：取较大的数字
Integer num1 = 100;
Integer num2 = 200;
Integer maxNum = ObjectUtils.max(num1, num2);
// 结果：200

// 示例3：处理 null
LocalDateTime date1 = null;
LocalDateTime date2 = LocalDateTime.now();
LocalDateTime maxDate = ObjectUtils.max(date1, date2);
// 结果：LocalDateTime.now()（date2）

// 示例4：取最新的更新时间
LocalDateTime updateTime1 = user.getUpdateTime();
LocalDateTime updateTime2 = user.getPasswordUpdateTime();
LocalDateTime latestTime = ObjectUtils.max(updateTime1, updateTime2);
```

**项目实际使用场景**:
- **取最新时间**: 获取用户的最后活动时间
  ```java
  // 用户最后活动时间 = max(登录时间, 操作时间)
  LocalDateTime lastLoginTime = user.getLastLoginTime();
  LocalDateTime lastOperateTime = user.getLastOperateTime();
  LocalDateTime lastActiveTime = ObjectUtils.max(lastLoginTime, lastOperateTime);
  ```

---

#### `defaultIfNull(T... array)` - 返回第一个非 null 值
**作用**: 返回数组中第一个非 null 的元素

**参数**:
- `array`: 对象数组

**返回值**: 第一个非 null 的对象，如果全部为 null 则返回 null

**使用示例**:
```java
// 示例1：获取默认值
String name = ObjectUtils.defaultIfNull(
    user.getNickname(),
    user.getUsername(),
    "匿名用户"
);
// 优先使用昵称，其次用户名，最后使用默认值

// 示例2：配置优先级
Integer timeout = ObjectUtils.defaultIfNull(
    appConfig.getTimeout(),      // 应用配置
    defaultConfig.getTimeout(),  // 默认配置
    30000                        // 硬编码默认值
);

// 示例3：多级回退
String address = ObjectUtils.defaultIfNull(
    user.getDetailAddress(),     // 详细地址
    user.getCityName(),          // 城市
    user.getProvinceName(),      // 省份
    "未知地址"
);
```

**项目实际使用场景**:
- **显示用户名**: 优先使用昵称，其次用户名
  ```java
  // 获取用户显示名称
  String displayName = ObjectUtils.defaultIfNull(
      user.getNickname(),   // 优先昵称
      user.getUsername(),   // 其次用户名
      "匿名用户"           // 默认值
  );
  ```

---

#### `equalsAny(T obj, T... array)` - 判断是否在数组中
**作用**: 判断对象是否等于数组中的任意一个元素

**参数**:
- `obj`: 待判断的对象
- `array`: 对象数组

**返回值**: true-在数组中，false-不在数组中

**使用示例**:
```java
// 示例1：判断状态
Integer status = order.getStatus();
if (ObjectUtils.equalsAny(status, OrderStatusEnum.PAID.getCode(),
                                  OrderStatusEnum.SHIPPED.getCode(),
                                  OrderStatusEnum.COMPLETED.getCode())) {
    // 订单已支付/已发货/已完成
}

// 示例2：判断权限
String userRole = user.getRole();
if (ObjectUtils.equalsAny(userRole, "ADMIN", "SUPER_ADMIN", "MANAGER")) {
    // 管理员权限
}

// 示例3：判断地区
String province = user.getProvince();
if (ObjectUtils.equalsAny(province, "北京", "上海", "广州", "深圳")) {
    // 一线城市用户
}
```

**项目实际使用场景**:
- **地区判断**: 判断是否为特定区域
  ```java
  // ashore-module-member/ashore-module-member-biz/src/main/java/com/example/ashore/module/member/service/address/MemberAddressServiceImpl.java
  // 判断是否为包邮地区
  String province = address.getProvince();
  boolean isFreeShipping = ObjectUtils.equalsAny(province,
      "北京", "上海", "天津", "重庆");

  if (!isFreeShipping) {
      order.setShippingFee(calculateShippingFee());
  }
  ```

---

#### `isNotAllEmpty(Object... objs)` - 判断不是全部为空
**作用**: 判断是否不是全部为空（至少有一个非空）

**参数**:
- `objs`: 对象数组

**返回值**: true-至少有一个非空，false-全部为空

**使用示例**:
```java
// 示例1：表单验证
if (ObjectUtils.isNotAllEmpty(reqVO.getName(), reqVO.getMobile(), reqVO.getEmail())) {
    // 至少填写了一个联系方式
    processForm(reqVO);
} else {
    throw new BusinessException("请至少填写一个联系方式");
}

// 示例2：搜索条件判断
if (ObjectUtils.isNotAllEmpty(keyword, categoryId, brandId)) {
    // 有搜索条件
    return productService.search(keyword, categoryId, brandId);
} else {
    // 无搜索条件，返回默认列表
    return productService.getDefaultList();
}

// 示例3：数据完整性检查
if (!ObjectUtils.isNotAllEmpty(user.getName(), user.getAge(), user.getGender())) {
    throw new BusinessException("用户信息不完整");
}
```

---

## 四、PageUtils 类详解

### 4.1 类的整体介绍

`PageUtils` 是分页工具类，主要解决以下问题：

1. **计算起始位置**: 计算分页查询的起始位置（用于 MyBatis 分页）
2. **构建排序字段**: 通过 Lambda 表达式构建排序字段
3. **设置默认排序**: 为分页查询设置默认排序

**为什么需要？**
- MyBatis Plus 的分页需要计算起始位置
- 简化排序字段的构建
- 统一分页查询的排序规范

### 4.2 核心方法详解

#### `getStart(PageParam pageParam)` - 获取分页起始位置
**作用**: 计算分页查询的起始位置

**参数**:
- `pageParam`: 分页参数（包含 pageNo 和 pageSize）

**返回值**: 起始位置（从0开始）

**计算公式**: `(pageNo - 1) * pageSize`

**使用示例**:
```java
// 示例1：计算起始位置
PageParam pageParam = new PageParam();
pageParam.setPageNo(2);   // 第2页
pageParam.setPageSize(10); // 每页10条

int start = PageUtils.getStart(pageParam);
// 结果：10（(2-1) * 10）

// 示例2：实际应用（MyBatis）
int start = PageUtils.getStart(reqVO);
int limit = reqVO.getPageSize();
List<UserDO> users = userMapper.selectList(start, limit);
```

**项目实际使用场景**:
- **BPM 任务分页查询**: 计算 Flowable 任务查询的起始位置
  ```java
  // ashore-module-bpm/ashore-module-bpm-biz/src/main/java/com/example/ashore/module/bpm/service/task/BpmTaskServiceImpl.java
  @Override
  public PageResult<BpmTaskDO> getTaskPage(BpmTaskPageReqVO reqVO) {
      int start = PageUtils.getStart(reqVO);
      int limit = reqVO.getPageSize();

      // Flowable 任务查询
      TaskQuery taskQuery = taskService.createTaskQuery();
      List<Task> tasks = taskQuery.listPage(start, limit);
      long total = taskQuery.count();

      // 转换为 PageResult
      List<BpmTaskDO> list = convertList(tasks);
      return new PageResult<>(list, total);
  }
  ```

---

#### `buildSortingField(Func1<T, ?> func)` - 构建排序字段（默认倒序）
**作用**: 通过 Lambda 表达式构建排序字段，默认倒序

**参数**:
- `func`: Lambda 表达式（方法引用）

**返回值**: SortingField 对象

**使用示例**:
```java
// 示例1：构建排序字段（倒序）
SortingField sortingField = PageUtils.buildSortingField(UserDO::getCreateTime);
// 结果：SortingField(field="createTime", order="desc")

// 示例2：设置到分页参数
SortablePageParam pageParam = new SortablePageParam();
pageParam.setSortingFields(Collections.singletonList(
    PageUtils.buildSortingField(UserDO::getCreateTime)
));

// 实际查询
PageResult<UserDO> pageResult = userMapper.selectPage(pageParam);
// SQL: SELECT * FROM user ORDER BY create_time DESC
```

---

#### `buildSortingField(Func1<T, ?> func, String order)` - 构建排序字段（指定排序方式）
**作用**: 通过 Lambda 表达式构建排序字段，指定排序方式

**参数**:
- `func`: Lambda 表达式
- `order`: 排序方式（`SortingField.ORDER_ASC` 或 `SortingField.ORDER_DESC`）

**返回值**: SortingField 对象

**使用示例**:
```java
// 示例1：升序排序
SortingField sortingField = PageUtils.buildSortingField(
    UserDO::getCreateTime,
    SortingField.ORDER_ASC
);
// 结果：SortingField(field="createTime", order="asc")

// 示例2：多字段排序
List<SortingField> sortingFields = Arrays.asList(
    PageUtils.buildSortingField(OrderDO::getCreateTime, SortingField.ORDER_DESC),  // 创建时间倒序
    PageUtils.buildSortingField(OrderDO::getId, SortingField.ORDER_ASC)           // ID 升序
);

pageParam.setSortingFields(sortingFields);
// SQL: SELECT * FROM `order` ORDER BY create_time DESC, id ASC
```

---

#### `buildDefaultSortingField(SortablePageParam sortablePageParam, Func1<T, ?> func)` - 构建默认排序
**作用**: 如果分页参数没有指定排序字段，则设置默认排序（倒序）

**参数**:
- `sortablePageParam`: 可排序的分页参数
- `func`: 默认排序字段的 Lambda 表达式

**返回值**: 无（直接修改 sortablePageParam）

**使用示例**:
```java
// 示例：设置默认排序
SortablePageParam pageParam = reqVO;

// 如果前端没有传排序字段，默认按创建时间倒序
PageUtils.buildDefaultSortingField(pageParam, UserDO::getCreateTime);

// 查询
PageResult<UserDO> pageResult = userMapper.selectPage(pageParam);
// 如果前端传了排序字段，使用前端的
// 如果前端没传排序字段，使用默认的 create_time DESC
```

**项目实际使用场景**:
- **商品统计**: 默认按创建时间倒序
  ```java
  // ashore-module-mall/ashore-module-mall-biz/src/main/java/com/example/ashore/module/product/service/spu/ProductSpuServiceImpl.java
  @Override
  public PageResult<ProductSpuVO> getSpuPage(ProductSpuPageReqVO reqVO) {
      // 设置默认排序
      PageUtils.buildDefaultSortingField(reqVO, ProductSpuDO::getCreateTime);

      // 查询
      PageResult<ProductSpuDO> pageResult = productSpuMapper.selectPage(reqVO);
      return BeanUtils.toBean(pageResult, ProductSpuVO.class);
  }
  ```

---

## 五、实战场景总结

### 场景1：用户详情查询（单对象转换+回调）
```java
@Override
public UserDetailVO getUserDetail(Long id) {
    // 1. 查询用户
    UserDO user = userMapper.selectById(id);

    // 2. 转换为 VO 并补充关联数据
    return BeanUtils.toBean(user, UserDetailVO.class, vo -> {
        // 补充部门名称
        DeptDO dept = deptService.getDept(user.getDeptId());
        vo.setDeptName(dept != null ? dept.getName() : null);

        // 补充角色列表
        List<RoleDO> roles = roleService.getRolesByUserId(id);
        vo.setRoleNames(CollectionUtils.convertList(roles, RoleDO::getName));

        // 补充岗位列表
        List<PostDO> posts = postService.getPostsByUserId(id);
        vo.setPostNames(CollectionUtils.convertList(posts, PostDO::getName));
    });
}
```

### 场景2：订单列表查询（分页转换+回调）
```java
@Override
public PageResult<OrderVO> getOrderPage(OrderPageReqVO reqVO) {
    // 1. 设置默认排序
    PageUtils.buildDefaultSortingField(reqVO, OrderDO::getCreateTime);

    // 2. 分页查询
    PageResult<OrderDO> pageResult = orderMapper.selectPage(reqVO);

    // 3. 转换为 VO 并补充关联数据
    return BeanUtils.toBean(pageResult, OrderVO.class, vo -> {
        // 补充用户名
        UserDO user = userService.getUser(vo.getUserId());
        vo.setUserName(user != null ? user.getName() : null);

        // 补充商品名
        ProductDO product = productService.getProduct(vo.getProductId());
        vo.setProductName(product != null ? product.getName() : null);

        // 计算优惠金额
        vo.setDiscountAmount(vo.getTotalAmount() - vo.getPayAmount());

        // 设置状态文本
        vo.setStatusText(OrderStatusEnum.getByCode(vo.getStatus()).getName());
    });
}
```

### 场景3：用户更新（属性复制）
```java
@Override
public void updateUser(UserUpdateReqVO reqVO) {
    // 1. 查询现有用户
    UserDO user = userMapper.selectById(reqVO.getId());
    if (user == null) {
        throw new BusinessException("用户不存在");
    }

    // 2. 复制属性
    BeanUtils.copyProperties(reqVO, user);

    // 3. 设置更新时间
    user.setUpdateTime(LocalDateTime.now());

    // 4. 更新到数据库
    userMapper.updateById(user);
}
```

### 场景4：商品复制（克隆对象）
```java
@Override
public Long copyProduct(Long productId) {
    // 1. 查询原商品
    ProductDO originalProduct = productMapper.selectById(productId);
    if (originalProduct == null) {
        throw new BusinessException("商品不存在");
    }

    // 2. 克隆商品（ID 自动设为 null）
    ProductDO newProduct = ObjectUtils.cloneIgnoreId(originalProduct, product -> {
        // 修改商品名称
        product.setName(product.getName() + "-副本");

        // 设置为草稿状态
        product.setStatus(ProductStatusEnum.DRAFT.getCode());

        // 重置销量
        product.setSales(0);

        // 设置创建时间
        product.setCreateTime(LocalDateTime.now());
    });

    // 3. 插入新商品
    productMapper.insert(newProduct);

    return newProduct.getId();
}
```

### 场景5：权限判断（equalsAny）
```java
@Override
public boolean hasPermission(Long userId, String resource) {
    // 1. 查询用户
    UserDO user = userService.getUser(userId);

    // 2. 判断是否为管理员（管理员拥有所有权限）
    if (ObjectUtils.equalsAny(user.getRole(), "SUPER_ADMIN", "ADMIN")) {
        return true;
    }

    // 3. 普通用户检查资源权限
    return permissionService.hasPermission(userId, resource);
}
```

### 场景6：多字段排序
```java
@Override
public PageResult<ProductVO> getProductPage(ProductPageReqVO reqVO) {
    // 1. 构建排序字段
    List<SortingField> sortingFields = new ArrayList<>();

    // 销量倒序
    sortingFields.add(PageUtils.buildSortingField(
        ProductDO::getSales,
        SortingField.ORDER_DESC
    ));

    // 价格升序
    sortingFields.add(PageUtils.buildSortingField(
        ProductDO::getPrice,
        SortingField.ORDER_ASC
    ));

    // 创建时间倒序
    sortingFields.add(PageUtils.buildSortingField(
        ProductDO::getCreateTime,
        SortingField.ORDER_DESC
    ));

    // 2. 设置排序字段
    reqVO.setSortingFields(sortingFields);

    // 3. 分页查询
    PageResult<ProductDO> pageResult = productMapper.selectPage(reqVO);

    // 4. 转换为 VO
    return BeanUtils.toBean(pageResult, ProductVO.class);
}
```

---

## 六、注意事项

### 6.1 BeanUtils
1. **属性名必须一致**: 源对象和目标对象的属性名必须相同
2. **null 值会被复制**: `copyProperties` 会将 null 值也复制过去
3. **深拷贝**: `toBean` 是浅拷贝，嵌套对象仍是同一个引用
4. **性能考虑**: 大量对象转换时考虑使用 MapStruct

### 6.2 ObjectUtils
1. **cloneIgnoreId 要求**: 对象必须有 id 字段（通过反射获取）
2. **max 要求**: 对象必须实现 Comparable 接口
3. **equalsAny**: 使用 `equals()` 方法比较，注意重写 equals

### 6.3 PageUtils
1. **起始位置从 0 开始**: getStart 返回的是从 0 开始的索引
2. **Lambda 表达式**: buildSortingField 使用 Hutool 的 LambdaUtil 解析字段名
3. **默认排序**: buildDefaultSortingField 只在没有排序字段时才生效

---

## 七、常见问题

### Q1: toBean 是深拷贝还是浅拷贝？
A: 浅拷贝。嵌套对象仍然是同一个引用。如果需要深拷贝，使用 `ObjectUtil.cloneByStream()`。

### Q2: copyProperties 会复制 null 值吗？
A: 会。null 值也会被复制，会覆盖目标对象的值。

### Q3: 为什么要用 cloneIgnoreId 而不是直接 clone？
A: 因为克隆后插入数据库需要生成新的 ID，自动将 ID 设为 null 更方便。

### Q4: buildSortingField 支持多字段排序吗？
A: 支持。创建多个 SortingField 并添加到 List 中即可。

### Q5: toBean 性能如何？
A: 基于反射，性能一般。大量对象转换建议使用 MapStruct（编译期生成代码，性能更好）。

### Q6: equalsAny 和 CollectionUtils.containsAny 有什么区别？
A:
- `ObjectUtils.equalsAny(obj, arr)`: 判断 obj 是否在 arr 中
- `CollectionUtils.containsAny(source, targets)`: 判断 source 是否在 targets 中
- 两者功能相同，只是参数顺序不同

---

## 八、最佳实践

### 实践1: Controller 统一使用 toBean 转换
```java
// Controller 层统一使用 BeanUtils.toBean
@GetMapping("/get")
public CommonResult<UserVO> getUser(@RequestParam Long id) {
    UserDO user = userService.getUser(id);
    return success(BeanUtils.toBean(user, UserVO.class));
}
```

### 实践2: 复杂转换使用回调
```java
// 需要补充关联数据时，使用回调
return BeanUtils.toBean(user, UserVO.class, vo -> {
    vo.setDeptName(deptService.getDept(user.getDeptId()).getName());
    vo.setRoleNames(getRoleNames(user.getId()));
});
```

### 实践3: 分页查询使用 buildDefaultSortingField
```java
// 分页查询统一设置默认排序
PageUtils.buildDefaultSortingField(reqVO, OrderDO::getCreateTime);
PageResult<OrderDO> pageResult = orderMapper.selectPage(reqVO);
```

### 实践4: 克隆测试数据使用 cloneIgnoreId
```java
// 测试用例中快速创建测试数据
UserDO testUser = ObjectUtils.cloneIgnoreId(mockUser, user -> {
    user.setName("测试用户");
});
```

---

## 九、运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Controller、Service 等需要对象转换和分页的地方
- **依赖库**:
  - Hutool (`cn.hutool.core.bean`, `cn.hutool.core.util`, `cn.hutool.core.lang`)
  - 项目内部类 (`PageResult`, `SortingField`)
- **设计模式**: 门面模式（封装复杂的对象操作，提供简单接口）
- **线程安全**: 所有方法都是无状态的，线程安全

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**维护者**: Ashore 团队  
