# 数据校验工具类使用指南

## 目录
- [一、包概览](#一包概览)
- [二、ValidationUtils - 校验工具类](#二validationutils---校验工具类)
- [三、实战场景总结](#三实战场景总结)
- [四、常见问题](#四常见问题)
- [五、最佳实践](#五最佳实践)

---

## 一、包概览

`com.example.ashore.framework.common.util.validation` 包提供了数据校验相关的工具类，主要用于格式验证和对象字段校验。

### 1.1 包含的工具类

| 工具类 | 作用 | 核心能力 |
|--------|------|---------|
| `ValidationUtils` | 数据校验工具类 | 格式校验（手机号、URL、XML NCName）、JSR-303 对象校验 |

### 1.2 设计理念

- **二次封装**: 基于 JSR-303（Jakarta Validation）和正则表达式封装
- **分组校验**: 支持根据不同业务场景使用不同的校验规则
- **异常统一**: 校验失败统一抛出 `ConstraintViolationException`
- **简化调用**: 提供静态方法，无需手动创建 Validator 实例

### 1.3 依赖库

- Jakarta Validation (`jakarta.validation`)
- Hutool (`cn.hutool.core`)
- Spring Framework (`org.springframework.util`)

---

## 二、ValidationUtils - 校验工具类

### 2.1 类的整体介绍

`ValidationUtils` 是一个数据校验工具类，提供了两大类功能：
1. **格式校验**: 手机号、URL、XML NCName 等常见格式的正则校验
2. **对象校验**: 基于 JSR-303 规范的对象字段校验，支持分组校验

**核心特点**:
- 所有方法都是静态的，通过 `ValidationUtils.方法名()` 调用
- 格式校验返回布尔值，对象校验失败抛出异常
- 支持 JSR-303 分组校验（Group Validation）

**为什么要二次封装**:
1. **简化调用**: 原生 JSR-303 需要手动创建 Validator，代码冗长
2. **统一规范**: 提供项目统一的格式校验正则表达式
3. **异常处理**: 统一异常类型，方便全局异常处理
4. **分组支持**: 简化分组校验的使用

---

### 2.2 格式校验方法

#### 2.2.1 isMobile - 手机号校验

**方法签名**:
```java
public static boolean isMobile(String mobile)
```

**作用**: 校验字符串是否为有效的中国大陆手机号

**正则规则**:
```java
^(?:(?:\+|00)86)?1(?:(?:3[\d])|(?:4[0,1,4-9])|(?:5[0-3,5-9])|(?:6[2,5-7])|(?:7[0-8])|(?:8[\d])|(?:9[0-3,5-9]))\d{8}$
```

**支持的手机号段**:
- 130-139、140-141、144-149（移动、联通、电信）
- 150-153、155-159（移动、联通、电信）
- 162、165-167（电信、虚拟运营商）
- 170-178（虚拟运营商）
- 180-189（移动、联通、电信）
- 190-193、195-199（虚拟运营商、电信）

**使用示例**:
```java
// 示例1：基本使用
boolean valid1 = ValidationUtils.isMobile("13800138000");  // true
boolean valid2 = ValidationUtils.isMobile("12345678901");  // false
boolean valid3 = ValidationUtils.isMobile("");             // false

// 示例2：支持 +86 前缀
boolean valid4 = ValidationUtils.isMobile("+8613800138000");  // true
boolean valid5 = ValidationUtils.isMobile("008613800138000"); // true

// 示例3：在业务方法中使用
public void sendSms(String mobile, String content) {
    if (!ValidationUtils.isMobile(mobile)) {
        throw new IllegalArgumentException("手机号格式不正确");
    }
    // 发送短信
    smsService.send(mobile, content);
}
```

**项目实际使用**:
```java
// ashore-framework/MobileValidator.java:22
// 自定义 @Mobile 注解的校验器实现
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    // 如果手机号为空，默认不校验，即校验通过
    if (StrUtil.isEmpty(value)) {
        return true;
    }
    // 校验手机
    return ValidationUtils.isMobile(value);
}
```

**对比原生写法**:
```java
// ❌ 原生正则写法（容易出错，不易维护）
private static final String MOBILE_REGEX = "^1[3-9]\\d{9}$";  // 过于简单，不准确
boolean valid = mobile != null && mobile.matches(MOBILE_REGEX);

// ✅ ValidationUtils（准确、易用）
boolean valid = ValidationUtils.isMobile(mobile);
```

---

#### 2.2.2 isURL - URL 校验

**方法签名**:
```java
public static boolean isURL(String url)
```

**作用**: 校验字符串是否为有效的 URL

**正则规则**:
```java
^(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]
```

**支持的协议**:
- http、https
- ftp
- file

**使用示例**:
```java
// 示例1：HTTP/HTTPS URL
boolean valid1 = ValidationUtils.isURL("https://www.baidu.com");        // true
boolean valid2 = ValidationUtils.isURL("http://example.com/path?q=1");  // true

// 示例2：FTP URL
boolean valid3 = ValidationUtils.isURL("ftp://ftp.example.com/file");   // true

// 示例3：FILE URL
boolean valid4 = ValidationUtils.isURL("file:///C:/Users/test.txt");    // true

// 示例4：非法 URL
boolean valid5 = ValidationUtils.isURL("not-a-url");                    // false
boolean valid6 = ValidationUtils.isURL("");                             // false

// 示例5：在业务方法中使用
public void saveWebhook(String webhookUrl) {
    if (!ValidationUtils.isURL(webhookUrl)) {
        throw new IllegalArgumentException("Webhook URL 格式不正确");
    }
    // 保存 Webhook 配置
    webhookService.save(webhookUrl);
}
```

**注意事项**:
- 该方法在项目中未被实际使用，可能是预留方法
- 正则较为宽松，只检查基本格式，不检查 URL 的可访问性
- 如需严格校验，建议使用 Spring 的 `@URL` 注解

---

#### 2.2.3 isXmlNCName - XML NCName 校验

**方法签名**:
```java
public static boolean isXmlNCName(String str)
```

**作用**: 校验字符串是否符合 XML NCName（Non-Colonized Name）规范

**正则规则**:
```java
[a-zA-Z_][\\-_.0-9_a-zA-Z$]*
```

**XML NCName 规范**:
- 必须以字母（a-z, A-Z）或下划线（_）开头
- 后续字符可以是字母、数字（0-9）、下划线（_）、点（.）、横杠（-）或美元符号（$）
- 不能包含空格、冒号（:）等特殊字符

**使用示例**:
```java
// 示例1：合法的 NCName
boolean valid1 = ValidationUtils.isXmlNCName("processKey");      // true
boolean valid2 = ValidationUtils.isXmlNCName("_privateKey");     // true
boolean valid3 = ValidationUtils.isXmlNCName("my-process-1.0");  // true
boolean valid4 = ValidationUtils.isXmlNCName("$systemKey");      // true

// 示例2：非法的 NCName
boolean valid5 = ValidationUtils.isXmlNCName("123abc");          // false（数字开头）
boolean valid6 = ValidationUtils.isXmlNCName("-abc");            // false（横杠开头）
boolean valid7 = ValidationUtils.isXmlNCName("my:key");          // false（包含冒号）
boolean valid8 = ValidationUtils.isXmlNCName("my key");          // false（包含空格）
boolean valid9 = ValidationUtils.isXmlNCName("");                // false（空字符串）
```

**项目实际使用**:
```java
// ashore-module-bpm/BpmModelServiceImpl.java:102
// BPM 流程模型标识（Key）校验
@Override
@Transactional(rollbackFor = Exception.class)
public String createModel(@Valid BpmModelSaveReqVO createReqVO) {
    if (!ValidationUtils.isXmlNCName(createReqVO.getKey())) {
        throw exception(MODEL_KEY_VALID);
    }
    // 1. 校验流程标识已经存在
    Model keyModel = getModelByKey(createReqVO.getKey());
    if (keyModel != null) {
        throw exception(MODEL_KEY_EXISTS, createReqVO.getKey());
    }
    // ... 后续创建流程模型逻辑
}
```

**为什么需要 NCName 校验**:
- BPM 流程模型的 Key 会用于生成 BPMN XML 文件
- BPMN XML 中的元素 ID 必须符合 XML NCName 规范
- 不符合规范的 Key 会导致 XML 解析失败

**对比原生写法**:
```java
// ❌ 自己写正则（容易出错）
boolean valid = str != null && str.matches("[a-zA-Z_][\\w\\-\\.$]*");

// ✅ ValidationUtils（正确、易用）
boolean valid = ValidationUtils.isXmlNCName(str);
```

---

### 2.3 对象校验方法

#### 2.3.1 validate - 对象校验（无需传入 Validator）

**方法签名**:
```java
public static void validate(Object object, Class<?>... groups)
```

**作用**: 对对象进行 JSR-303 校验，自动创建 Validator 实例

**参数说明**:
- `object`: 需要校验的对象
- `groups`: 校验分组（可选），支持多个分组

**异常**:
- 校验失败抛出 `ConstraintViolationException`

**使用示例**:
```java
// 示例1：基本使用（无分组）
public class UserDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Length(min = 6, max = 20, message = "密码长度必须在6-20位之间")
    private String password;
}

UserDTO user = new UserDTO();
user.setUsername("");
user.setPassword("123");

try {
    ValidationUtils.validate(user);  // 抛出异常
} catch (ConstraintViolationException ex) {
    // 异常信息包含所有校验失败的字段
    ex.getConstraintViolations().forEach(violation -> {
        System.out.println(violation.getMessage());
        // 输出：
        // 用户名不能为空
        // 密码长度必须在6-20位之间
    });
}
```

**项目实际使用场景1 - 用户导入校验**:
```java
// ashore-module-system/AdminUserServiceImpl.java:478
// 批量导入用户时，对每个用户数据进行校验
importUsers.forEach(importUser -> {
    // 2.1.1 校验字段是否符合要求
    try {
        ValidationUtils.validate(BeanUtils.toBean(importUser, UserSaveReqVO.class)
            .setPassword(initPassword));
    } catch (ConstraintViolationException ex){
        respVO.getFailureUsernames().put(importUser.getUsername(), ex.getMessage());
        return;
    }
    // ... 后续处理逻辑
});
```

**项目实际使用场景2 - IoT 设备导入校验**:
```java
// ashore-module-iot/IotDeviceServiceImpl.java:342
// 批量导入 IoT 设备时的数据校验
importDevices.forEach(importDevice -> {
    try {
        // 2.1.1 校验字段是否符合要求
        try {
            ValidationUtils.validate(importDevice);
        } catch (ConstraintViolationException ex) {
            respVO.getFailureDeviceNames().put(importDevice.getDeviceName(),
                ex.getMessage());
            return;
        }
        // ... 后续处理逻辑
    }
});
```

**项目实际使用场景3 - 支付订单统一下单**:
```java
// ashore-module-pay/AbstractPayClient.java:86
// 支付客户端执行统一下单前，先校验请求参数
@Override
public final PayOrderRespDTO unifiedOrder(PayOrderUnifiedReqDTO reqDTO) {
    ValidationUtils.validate(reqDTO);

    // 执行统一下单
    PayOrderRespDTO resp;
    try {
        resp = doUnifiedOrder(reqDTO);
    } catch (ServiceException ex) {
        throw ex;
    } catch (Throwable ex) {
        log.error("[unifiedOrder][客户端({}) request({}) 发起支付异常]",
            getId(), toJsonString(reqDTO), ex);
        throw buildPayException(ex);
    }
    return resp;
}
```

**项目实际使用场景4 - 支付退款统一退款**:
```java
// ashore-module-pay/AbstractPayClient.java:141
// 支付客户端执行统一退款前，先校验退款请求参数
@Override
public final PayRefundRespDTO unifiedRefund(PayRefundUnifiedReqDTO reqDTO) {
    ValidationUtils.validate(reqDTO);

    // 执行统一退款
    PayRefundRespDTO resp;
    try {
        resp = doUnifiedRefund(reqDTO);
    } catch (ServiceException ex) {
        throw ex;
    } catch (Throwable ex) {
        log.error("[unifiedRefund][客户端({}) request({}) 发起退款异常]",
            getId(), toJsonString(reqDTO), ex);
        throw buildPayException(ex);
    }
    return resp;
}
```

**对比原生写法**:
```java
// ❌ 原生 JSR-303（代码冗长）
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
Set<ConstraintViolation<UserDTO>> violations = validator.validate(user);
if (!violations.isEmpty()) {
    throw new ConstraintViolationException(violations);
}

// ✅ ValidationUtils（简洁）
ValidationUtils.validate(user);
```

---

#### 2.3.2 validate - 对象校验（传入 Validator，支持分组）

**方法签名**:
```java
public static void validate(Validator validator, Object object, Class<?>... groups)
```

**作用**: 对对象进行 JSR-303 分组校验，需要传入 Validator 实例

**参数说明**:
- `validator`: Validator 实例（通常通过依赖注入获取）
- `object`: 需要校验的对象
- `groups`: 校验分组，支持多个分组

**异常**:
- 校验失败抛出 `ConstraintViolationException`

**分组校验的作用**:
- 同一个字段在不同业务场景下有不同的校验规则
- 通过分组可以在不同场景下只校验部分字段

**使用示例**:
```java
// 示例1：定义分组接口
public interface CreateGroup {}
public interface UpdateGroup {}

// 示例2：在字段上指定分组
public class UserDTO {
    @Null(groups = CreateGroup.class, message = "创建时ID必须为空")
    @NotNull(groups = UpdateGroup.class, message = "更新时ID不能为空")
    private Long id;

    @NotBlank(message = "用户名不能为空")
    private String username;
}

// 示例3：使用分组校验
@Autowired
private Validator validator;

// 创建场景 - 只校验 CreateGroup 分组的规则
UserDTO createUser = new UserDTO();
createUser.setId(1L);  // 违反 CreateGroup 规则
ValidationUtils.validate(validator, createUser, CreateGroup.class);
// 抛出异常：创建时ID必须为空

// 更新场景 - 只校验 UpdateGroup 分组的规则
UserDTO updateUser = new UserDTO();
updateUser.setId(null);  // 违反 UpdateGroup 规则
ValidationUtils.validate(validator, updateUser, UpdateGroup.class);
// 抛出异常：更新时ID不能为空
```

**项目实际使用场景1 - 微信公众号消息分组校验**:
```java
// ashore-module-mp/MpUtils.java:51
// 根据消息类型使用不同的校验分组
public static void validateMessage(Validator validator, String type, Object message) {
    // 获得对应的校验 group
    Class<?> group;
    switch (type) {
        case WxConsts.XmlMsgType.TEXT:
            group = TextMessageGroup.class;
            break;
        case WxConsts.XmlMsgType.IMAGE:
            group = ImageMessageGroup.class;
            break;
        case WxConsts.XmlMsgType.VOICE:
            group = VoiceMessageGroup.class;
            break;
        case WxConsts.XmlMsgType.VIDEO:
            group = VideoMessageGroup.class;
            break;
        case WxConsts.XmlMsgType.NEWS:
            group = NewsMessageGroup.class;
            break;
        case WxConsts.XmlMsgType.MUSIC:
            group = MusicMessageGroup.class;
            break;
        default:
            throw new IllegalArgumentException("不支持的消息类型：" + type);
    }
    // 执行校验
    ValidationUtils.validate(validator, message, group);
}
```

**项目实际使用场景2 - 微信公众号菜单按钮分组校验**:
```java
// ashore-module-mp/MpUtils.java:89
// 根据按钮类型使用不同的校验分组
public static void validateButton(Validator validator, String type,
                                  String messageType, Object button) {
    if (StrUtil.isBlank(type)) {
        return;
    }
    // 获得对应的校验 group
    Class<?> group;
    switch (type) {
        case WxConsts.MenuButtonType.CLICK:
            group = ClickButtonGroup.class;
            validateMessage(validator, messageType, button); // 额外校验回复消息
            break;
        case WxConsts.MenuButtonType.VIEW:
            group = ViewButtonGroup.class;
            break;
        case WxConsts.MenuButtonType.MINIPROGRAM:
            group = MiniProgramButtonGroup.class;
            break;
        case WxConsts.MenuButtonType.ARTICLE_VIEW_LIMITED:
            group = ArticleViewLimitedButtonGroup.class;
            break;
        default:
            throw new IllegalArgumentException("不支持的按钮类型：" + type);
    }
    // 执行校验
    ValidationUtils.validate(validator, button, group);
}
```

**项目实际使用场景3 - 验证码开关状态下的分组校验**:
```java
// ashore-module-system/AdminAuthServiceImpl.java:205
// 验证码功能开启时才校验验证码字段
private ResponseModel doValidateCaptcha(CaptchaVerificationReqVO reqVO) {
    // 如果验证码关闭，则不进行校验
    if (!captchaEnable) {
        return ResponseModel.success();
    }
    // 验证码开启时，使用特定分组校验
    ValidationUtils.validate(validator, reqVO,
        CaptchaVerificationReqVO.CodeEnableGroup.class);

    CaptchaVO captchaVO = new CaptchaVO();
    captchaVO.setCaptchaVerification(reqVO.getCaptchaVerification());
    return captchaService.verification(captchaVO);
}
```

**项目实际使用场景4 - 分销提现方式分组校验**:
```java
// ashore-module-mall/AppBrokerageWithdrawCreateReqVO.java:74-84
// 根据提现方式校验不同字段
public void validate(Validator validator) {
    if (BrokerageWithdrawTypeEnum.WALLET.getType().equals(type)) {
        ValidationUtils.validate(validator, this, Wallet.class);
    } else if (BrokerageWithdrawTypeEnum.BANK.getType().equals(type)) {
        ValidationUtils.validate(validator, this, Bank.class);
    } else if (BrokerageWithdrawTypeEnum.WECHAT_QR.getType().equals(type)) {
        ValidationUtils.validate(validator, this, WechatQR.class);
    } else if (BrokerageWithdrawTypeEnum.WECHAT_API.getType().equals(type)) {
        ValidationUtils.validate(validator, this, WechatApi.class);
    } else if (BrokerageWithdrawTypeEnum.ALIPAY_QR.getType().equals(type)) {
        ValidationUtils.validate(validator, this, AlipayQR.class);
    } else if (BrokerageWithdrawTypeEnum.ALIPAY_API.getType().equals(type)) {
        ValidationUtils.validate(validator, this, AlipayApi.class);
    }
}

// 对应的分组定义
public interface Wallet {}
public interface Bank {}
public interface WechatQR {}
public interface WechatApi {}
public interface AlipayQR {}
public interface AlipayApi {}

// 字段分组校验
@NotNull(groups = {Bank.class}, message = "账号不能为空")
private String accountNo;

@NotNull(groups = {Bank.class}, message = "开户行不能为空")
private String openingBank;

@NotNull(groups = {WechatQR.class, AlipayQR.class}, message = "收款码不能为空")
private String qrCode;
```

**项目实际使用场景5 - 微信支付配置版本分组校验**:
```java
// ashore-module-pay/WxPayClientConfig.java:102
// 根据微信支付 API 版本（V2/V3）校验不同字段
@Override
public void validate(Validator validator) {
    ValidationUtils.validate(validator, this,
            API_VERSION_V2.equals(this.getApiVersion()) ? V2.class : V3.class);
}

// V2 版本需要的字段
@NotBlank(message = "API 密钥不能为空", groups = V2.class)
private String apiSecret;

// V3 版本需要的字段
@NotBlank(message = "API v3 密钥不能为空", groups = V3.class)
private String apiV3Key;

@NotBlank(message = "私钥不能为空", groups = V3.class)
private String privateKeyContent;
```

**项目实际使用场景6 - 支付宝支付配置模式分组校验**:
```java
// ashore-module-pay/AlipayPayClientConfig.java:124
// 根据支付宝模式（公钥/证书）校验不同字段
@Override
public void validate(Validator validator) {
    ValidationUtils.validate(validator, this,
            MODE_PUBLIC_KEY.equals(this.getMode()) ? ModePublicKey.class : ModeCertificate.class);
}

// 公钥模式需要的字段
@NotBlank(message = "公钥不能为空", groups = ModePublicKey.class)
private String alipayPublicKey;

// 证书模式需要的字段
@NotBlank(message = "公钥证书不能为空", groups = ModeCertificate.class)
private String alipayPublicCertContent;

@NotBlank(message = "根证书不能为空", groups = ModeCertificate.class)
private String alipayRootCertContent;
```

**项目实际使用场景7 - 文件存储配置参数校验**:
```java
// ashore-module-infra/FileConfigServiceImpl.java:119
// 解析文件存储配置后校验
private FileClientConfig parseClientConfig(Integer storage, Map<String, Object> config) {
    // 获取配置类
    Class<? extends FileClientConfig> configClass = FileStorageEnum.getByStorage(storage)
            .getConfigClass();
    FileClientConfig clientConfig = JsonUtils.parseObject2(JsonUtils.toJsonString(config),
        configClass);
    // 参数校验
    ValidationUtils.validate(validator, clientConfig);
    // 设置参数
    return clientConfig;
}
```

---

## 三、实战场景总结

### 3.1 典型业务场景

#### 场景1：数据导入时的批量校验

```java
// 需求：批量导入用户数据，每条数据都需要校验

@Override
public UserImportRespVO importUsers(List<UserImportExcelVO> importUsers,
                                    boolean updateSupport) {
    UserImportRespVO respVO = UserImportRespVO.builder()
        .createUsernames(new ArrayList<>())
        .updateUsernames(new ArrayList<>())
        .failureUsernames(new LinkedHashMap<>()).build();

    importUsers.forEach(importUser -> {
        try {
            // 1. 转换为 VO 并校验
            UserSaveReqVO reqVO = BeanUtils.toBean(importUser, UserSaveReqVO.class)
                .setPassword(initPassword);
            ValidationUtils.validate(reqVO);

            // 2. 业务校验
            // ...

            // 3. 保存或更新
            // ...
        } catch (ConstraintViolationException ex) {
            // 记录校验失败的用户
            respVO.getFailureUsernames().put(importUser.getUsername(), ex.getMessage());
        }
    });

    return respVO;
}
```

---

#### 场景2：根据业务类型动态选择校验分组

```java
// 需求：根据提现方式，校验不同的必填字段

public class WithdrawReqVO {
    @NotNull(message = "提现方式不能为空")
    private Integer type;  // 1-钱包 2-银行卡 3-微信 4-支付宝

    // 银行卡必填
    @NotBlank(groups = BankGroup.class, message = "银行卡号不能为空")
    private String bankCardNo;

    @NotBlank(groups = BankGroup.class, message = "开户行不能为空")
    private String bankName;

    // 微信/支付宝二维码必填
    @NotBlank(groups = QRCodeGroup.class, message = "收款码不能为空")
    private String qrCode;

    public void validate(Validator validator) {
        // 根据提现方式选择校验分组
        if (type.equals(2)) {  // 银行卡
            ValidationUtils.validate(validator, this, BankGroup.class);
        } else if (type.equals(3) || type.equals(4)) {  // 微信/支付宝
            ValidationUtils.validate(validator, this, QRCodeGroup.class);
        }
    }
}
```

---

#### 场景3：接口参数校验（支付/退款）

```java
// 需求：调用第三方支付接口前，校验请求参数完整性

@Override
public final PayOrderRespDTO unifiedOrder(PayOrderUnifiedReqDTO reqDTO) {
    // 1. 校验请求参数
    ValidationUtils.validate(reqDTO);

    // 2. 执行统一下单
    PayOrderRespDTO resp;
    try {
        resp = doUnifiedOrder(reqDTO);
    } catch (ServiceException ex) {
        throw ex;
    } catch (Throwable ex) {
        log.error("[unifiedOrder][客户端({}) request({}) 发起支付异常]",
            getId(), toJsonString(reqDTO), ex);
        throw buildPayException(ex);
    }

    return resp;
}
```

---

#### 场景4：配置参数的完整性校验

```java
// 需求：解析配置参数后，校验配置是否完整

private FileClientConfig parseClientConfig(Integer storage, Map<String, Object> config) {
    // 1. 获取配置类
    Class<? extends FileClientConfig> configClass =
        FileStorageEnum.getByStorage(storage).getConfigClass();

    // 2. JSON 转对象
    FileClientConfig clientConfig = JsonUtils.parseObject2(
        JsonUtils.toJsonString(config), configClass);

    // 3. 校验配置参数
    ValidationUtils.validate(validator, clientConfig);

    return clientConfig;
}
```

---

#### 场景5：BPM 流程标识校验

```java
// 需求：创建 BPM 流程模型时，校验流程 Key 符合 XML NCName 规范

@Override
@Transactional(rollbackFor = Exception.class)
public String createModel(@Valid BpmModelSaveReqVO createReqVO) {
    // 1. 校验流程 Key 格式
    if (!ValidationUtils.isXmlNCName(createReqVO.getKey())) {
        throw exception(MODEL_KEY_VALID);
    }

    // 2. 校验流程标识不重复
    Model keyModel = getModelByKey(createReqVO.getKey());
    if (keyModel != null) {
        throw exception(MODEL_KEY_EXISTS, createReqVO.getKey());
    }

    // 3. 创建流程模型
    Model model = repositoryService.newModel();
    BpmnModelUtils.setMainProcessId(model, createReqVO.getKey());
    // ...

    return model.getId();
}
```

---

### 3.2 性能优化技巧

#### 技巧1：复用 Validator 实例

```java
// ❌ 低效：每次校验都创建新的 Validator（内部会创建 ValidatorFactory）
public void validate(UserDTO user) {
    ValidationUtils.validate(user);  // 每次都创建 Validator
}

// ✅ 高效：注入 Validator 实例，多次复用
@Autowired
private Validator validator;

public void validate(UserDTO user) {
    ValidationUtils.validate(validator, user);  // 复用 Validator
}
```

---

#### 技巧2：提前校验，快速失败

```java
// ❌ 低效：先执行业务逻辑，最后才校验参数
public void processOrder(OrderDTO order) {
    // 1. 查询商品信息
    Product product = productService.getById(order.getProductId());

    // 2. 计算价格
    BigDecimal price = calculatePrice(order);

    // 3. 校验参数（放在最后）
    ValidationUtils.validate(order);

    // 4. 创建订单
    createOrder(order);
}

// ✅ 高效：先校验参数，快速失败
public void processOrder(OrderDTO order) {
    // 1. 先校验参数
    ValidationUtils.validate(order);

    // 2. 查询商品信息
    Product product = productService.getById(order.getProductId());

    // 3. 计算价格
    BigDecimal price = calculatePrice(order);

    // 4. 创建订单
    createOrder(order);
}
```

---

#### 技巧3：使用分组避免重复校验

```java
// ❌ 低效：重复定义校验规则
public class CreateUserDTO {
    @NotBlank(message = "用户名不能为空")
    @Length(min = 4, max = 20, message = "用户名长度4-20")
    private String username;
}

public class UpdateUserDTO {
    @NotNull(message = "ID不能为空")
    private Long id;

    @NotBlank(message = "用户名不能为空")
    @Length(min = 4, max = 20, message = "用户名长度4-20")
    private String username;
}

// ✅ 高效：使用分组，统一定义
public class UserDTO {
    @NotNull(groups = UpdateGroup.class, message = "ID不能为空")
    @Null(groups = CreateGroup.class, message = "创建时ID必须为空")
    private Long id;

    @NotBlank(message = "用户名不能为空")
    @Length(min = 4, max = 20, message = "用户名长度4-20")
    private String username;
}
```

---

## 四、常见问题

### Q1: 为什么校验失败没有抛出异常？

**A**: 可能是因为字段上没有加校验注解，或者注解配置不正确。

```java
// ❌ 错误：没有加注解
public class UserDTO {
    private String username;  // 没有任何校验注解
}

ValidationUtils.validate(user);  // 不会抛异常

// ✅ 正确：添加校验注解
public class UserDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
}
```

---

### Q2: 如何自定义校验错误信息？

**A**: 在注解的 `message` 属性中指定错误信息。

```java
public class UserDTO {
    @NotBlank(message = "用户名不能为空")
    @Length(min = 4, max = 20, message = "用户名长度必须在4-20位之间")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$",
             message = "密码至少8位，必须包含大小写字母和数字")
    private String password;
}
```

---

### Q3: 分组校验时，如何指定多个分组？

**A**: 在 `groups` 属性中使用数组。

```java
public class UserDTO {
    // 在创建和更新时都需要校验
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class},
              message = "用户名不能为空")
    private String username;

    // 只在更新时校验
    @NotNull(groups = UpdateGroup.class, message = "ID不能为空")
    private Long id;
}

// 校验时可以指定多个分组
ValidationUtils.validate(validator, user, CreateGroup.class, UpdateGroup.class);
```

---

### Q4: 如何校验嵌套对象？

**A**: 在嵌套对象字段上加 `@Valid` 注解。

```java
public class OrderDTO {
    @NotNull(message = "订单号不能为空")
    private String orderNo;

    @Valid  // 级联校验
    @NotNull(message = "收货地址不能为空")
    private AddressDTO address;
}

public class AddressDTO {
    @NotBlank(message = "收货人不能为空")
    private String name;

    @NotBlank(message = "手机号不能为空")
    private String mobile;
}

// 会同时校验 OrderDTO 和 AddressDTO
ValidationUtils.validate(order);
```

---

### Q5: 如何校验集合中的每个元素？

**A**: 在集合字段上加 `@Valid` 注解。

```java
public class BatchCreateUserDTO {
    @Valid  // 校验集合中的每个元素
    @NotEmpty(message = "用户列表不能为空")
    private List<UserDTO> users;
}

public class UserDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
}

// 会校验 users 集合中的每个 UserDTO
ValidationUtils.validate(batchCreateUser);
```

---

### Q6: isMobile 支持哪些手机号段？

**A**: 支持中国大陆所有主流运营商的手机号段（含虚拟运营商）。

```java
// 支持的号段示例
boolean valid1 = ValidationUtils.isMobile("13800138000");  // 移动
boolean valid2 = ValidationUtils.isMobile("15812345678");  // 联通
boolean valid3 = ValidationUtils.isMobile("18912345678");  // 电信
boolean valid4 = ValidationUtils.isMobile("17012345678");  // 虚拟运营商

// 支持 +86 前缀
boolean valid5 = ValidationUtils.isMobile("+8613800138000");
boolean valid6 = ValidationUtils.isMobile("008613800138000");
```

---

### Q7: 如何在不同环境下使用不同的校验规则？

**A**: 使用分组校验，根据环境动态选择分组。

```java
public interface DevGroup {}
public interface ProdGroup {}

public class ConfigDTO {
    // 开发环境不强制校验
    @NotBlank(groups = ProdGroup.class, message = "API密钥不能为空")
    private String apiKey;
}

// 根据环境选择分组
if (isProdEnv()) {
    ValidationUtils.validate(validator, config, ProdGroup.class);
} else {
    ValidationUtils.validate(validator, config, DevGroup.class);
}
```

---

## 五、最佳实践

### 5.1 何时使用 ValidationUtils

#### ✅ 推荐使用

1. **数据导入场景**: 批量导入时对每条数据进行校验
2. **接口参数校验**: 调用第三方接口前校验参数完整性
3. **配置参数校验**: 解析配置后校验配置是否有效
4. **动态校验**: 根据业务类型动态选择校验规则（分组校验）
5. **格式校验**: 手机号、URL、XML NCName 等格式校验

#### ❌ 不推荐使用

1. **Controller 层参数校验**: 应该使用 `@Valid` 或 `@Validated` 注解
2. **简单的非空判断**: 使用 `Objects.requireNonNull()` 或 `Assert.notNull()` 更简洁
3. **复杂业务规则校验**: 应该在 Service 层编写业务逻辑

---

### 5.2 Controller 层 vs Service 层校验

```java
// ✅ Controller 层：使用 @Valid 注解（自动校验）
@PostMapping("/create")
public CommonResult<Long> createUser(@Valid @RequestBody UserSaveReqVO reqVO) {
    return success(userService.createUser(reqVO));
}

// ✅ Service 层：使用 ValidationUtils（手动校验）
@Override
public Long importUsers(List<UserImportExcelVO> importUsers) {
    importUsers.forEach(importUser -> {
        try {
            // 手动校验
            ValidationUtils.validate(BeanUtils.toBean(importUser, UserSaveReqVO.class));
        } catch (ConstraintViolationException ex) {
            // 记录失败原因
            log.error("用户导入失败: {}", ex.getMessage());
        }
    });
}
```

---

### 5.3 分组校验的最佳实践

#### 1. 分组接口命名规范

```java
// ✅ 推荐：清晰的命名
public interface CreateGroup {}
public interface UpdateGroup {}
public interface ImportGroup {}

// ❌ 不推荐：模糊的命名
public interface Group1 {}
public interface Group2 {}
```

---

#### 2. 合理使用 Default 分组

```java
public class UserDTO {
    // 不指定 groups，默认属于 Default 分组（所有场景都校验）
    @NotBlank(message = "用户名不能为空")
    private String username;

    // 只在创建时校验
    @Null(groups = CreateGroup.class, message = "创建时ID必须为空")
    private Long id;

    // 只在更新时校验
    @NotNull(groups = UpdateGroup.class, message = "更新时ID不能为空")
    private Long id;
}

// 不指定分组时，只校验 Default 分组（即 username）
ValidationUtils.validate(validator, user);

// 指定分组时，同时校验 Default 分组和指定分组
ValidationUtils.validate(validator, user, CreateGroup.class);  // 校验 username + id(null)
```

---

#### 3. 分组继承

```java
// 定义分组继承关系
public interface CreateGroup extends Default {}
public interface UpdateGroup extends Default {}

public class UserDTO {
    // Default 分组的字段会在所有子分组中生效
    @NotBlank(message = "用户名不能为空")
    private String username;

    @NotNull(groups = UpdateGroup.class, message = "ID不能为空")
    private Long id;
}

// 校验 UpdateGroup 时，会同时校验 username（Default）和 id（UpdateGroup）
ValidationUtils.validate(validator, user, UpdateGroup.class);
```

---

### 5.4 异常处理的最佳实践

```java
// ✅ 推荐：统一的异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ConstraintViolationException.class)
    public CommonResult<?> handleConstraintViolationException(
            ConstraintViolationException ex) {
        // 提取所有校验错误信息
        String message = ex.getConstraintViolations().stream()
            .map(ConstraintViolation::getMessage)
            .collect(Collectors.joining("; "));

        return CommonResult.error(BAD_REQUEST.getCode(), message);
    }
}
```

---

### 5.5 自定义校验注解

```java
// 1. 定义注解
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MobileValidator.class)
public @interface Mobile {
    String message() default "手机号格式不正确";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 2. 实现校验器
public class MobileValidator implements ConstraintValidator<Mobile, String> {
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return ValidationUtils.isMobile(value);
    }
}

// 3. 使用注解
public class UserDTO {
    @Mobile(message = "手机号格式不正确")
    private String mobile;
}
```

---

## 六、运行机制总结

- **类型**: 静态工具类
- **触发方式**: 开发人员主动调用
- **调用位置**: Service 层、工具类、Validator 实现类
- **依赖库**: Jakarta Validation、Hutool、Spring
- **设计模式**: 门面模式（简化 JSR-303 的使用）

---

## 七、附录

### 7.1 常用校验注解速查表

| 注解 | 作用 | 示例 |
|------|------|------|
| `@NotNull` | 不能为 null | `@NotNull(message = "ID不能为空")` |
| `@NotBlank` | 不能为空字符串 | `@NotBlank(message = "用户名不能为空")` |
| `@NotEmpty` | 集合/数组不能为空 | `@NotEmpty(message = "列表不能为空")` |
| `@Null` | 必须为 null | `@Null(groups = CreateGroup.class)` |
| `@Size` | 字符串/集合长度限制 | `@Size(min = 1, max = 10)` |
| `@Length` | 字符串长度限制 | `@Length(min = 6, max = 20)` |
| `@Min` | 数字最小值 | `@Min(value = 0)` |
| `@Max` | 数字最大值 | `@Max(value = 100)` |
| `@Email` | 邮箱格式 | `@Email(message = "邮箱格式不正确")` |
| `@Pattern` | 正则表达式 | `@Pattern(regexp = "^[a-zA-Z0-9_]+$")` |
| `@Valid` | 级联校验 | `@Valid private AddressDTO address;` |

### 7.2 方法速查表

| 方法 | 作用 | 返回值 |
|------|------|--------|
| `isMobile(String mobile)` | 校验手机号 | boolean |
| `isURL(String url)` | 校验 URL | boolean |
| `isXmlNCName(String str)` | 校验 XML NCName | boolean |
| `validate(Object object, Class<?>... groups)` | 对象校验 | void（失败抛异常） |
| `validate(Validator validator, Object object, Class<?>... groups)` | 对象分组校验 | void（失败抛异常） |

---

**文档版本**: v1.0  
**最后更新**: 2025-10-19  
**维护者**: Ashore 团队  

